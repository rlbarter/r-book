{
  "hash": "fff9f116aae742e97cccc4e853c45e0e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Custom functions\"\nformat: html\neditor_options: \n  chunk_output_type: console\n---\n\n\n## A simple custom function\n\nIn this notebook, you will learn how to define your own functions. \n\nWe will start with a very simple function, that we will call `add_one()`, which will add 1 to any value it is given. \n\nThe simplest way to define `add_one()` is \n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  x + 1\n}\n```\n:::\n\n\nThe code that is run when you \"call\" your function is shown inside the curly parentheses. To \"call\" a function is to write the name of the function, followed by some parentheses inside which you provide a value for your argument, such as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nWhat is happening when you call `add_one(5)` is that `x` is temporarily being assigned the value `5`, and then the code inside the curly parentheses `x + 1` is run, with the result being returned as the output of the function. \n\n\nNote that by default, any custom R function you create will automatically return the final result that is computed. So for example, if your function contains multiple computations that would have output, such as the version below, when you call `add_one(5)`, you will only see the final computed result (i.e., you will see the output of `x + 1` but not `x - 1`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  x - 1\n  x + 1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\nFor this reason, it is common to explicitly provide a \"return statement\", which specifies what you want the output of your function to be. In the example below, we explicitly specify that we want the output of `add_one()` to be the output of the first computation `x - 1`, rather than the second one, `x + 1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  return(x - 1)\n  x + 1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n## The general syntax of a custom function\n\nThe general syntax of a custom function is shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_name <- function(arg) {\n  # code involve arg\n  return(object)\n}\n```\n:::\n\n\n\n\n\n## Exercise\n\nWrite a function called \"cube\" that returns the cubic of the argument  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncube <- function(value) {\n  cubed_value = value^3\n  return(cubed_value)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncube(value = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27\n```\n\n\n:::\n:::\n\n\n\n\n## Multiple arguments\n\nTo create a function with multiple arguments, you need to provide two arguments inside the function definition, separated by a comma. The function below has two arguments: `x` and `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy <- function(x, y) {\n  x + 2*y\n}\n```\n:::\n\n\nWhen you call this `add_xy()`, you can then specify a value for each argument, separated by a comma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(2, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\nWhen you have multiple arguments, funny things can start to happen when you don't name your arguments. \n\nWhat do you think will happen if you *first* provide a named argument for the *second* argument `y` by specifying `y = 2`, and then provide an unnamed argument afterwards?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(y = 2, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nR will be clever and it will first apply the named arguments by assigning `y` to the value 2, and then it will start at the beginning of the argument list and fill in the remaining argument, so `x` will be assigned to the value `5`.\n\nHowever, so that your code is easy to read and you don't have to remember which arguments appear in which order, it is good practice to always name your arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(x = 2, y = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\nNote that when you provide named arguments, it technically doesn't matter which order you provide them in (but this is *not* true when you don't provide named arguments!)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(y = 5, x = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\nAgain, note that even when you provide named arguments in a function call (e.g., in `add_xy(y = 5, x = 2)`), you are *not* defining a global version of the arguments, i.e., there is no `y` defined:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'y' not found\n```\n\n\n:::\n:::\n\n\nBefore we move on, what do you think will happen when you call `add_xy()` without any arguments inside the parentheses?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in add_xy(): argument \"x\" is missing, with no default\n```\n\n\n:::\n:::\n\n\nYou get an error, because we haven't specified any *default values* for the arguments which the function will use when an argument is not provided.\n\n### Default values\n\n\nTo provide *default* values for your arguments, you can assign the argument inside the function definition. In the example below, both `x` and `y` are given the default values of 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy <- function(x = 1, y = 1) {\n  x + 2*y\n}\n```\n:::\n\n\nNow if we run `add_xy()` without any arguments, we don't get an error! We get the same thing that we would have got if we had run `add_xy(x = 1, y = 1)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nWhat do you think will happen if we run `add_xy(4)`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nWhat happens is that the value `4` is assigned to the *first* argument, `x`, and the argument `y` is assigned it's default value of `1`.\n\n\nSimilarly, if you provide a value for the argument `y`, the default value for `x` will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n### Exercise\n\n\nWithout using the `mean()` function, write a function called `my_mean()` that takes four values as its arguments and computes their mean. Ensure that each argument has a default of 0. Use your function to compute the mean of the values 4, 5, 2, 1.\n\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean <- function(a = 0, b = 0, c = 0, d = 0) {\n  return((a + b + c + d) / 4)\n}\n```\n:::\n\n\nNote that when we run this function it is taking four separate arguments (rather than a vector, as the original mean function does):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean(4, 5, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nYou can define a function that instead takes a single vector as its argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean_vec <- function(vec) {\n  return(sum(vec) / length(vec))\n}\n```\n:::\n\n\nand then to run this function, you provide a vector by wrapping the four values inside `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean_vec(c(4, 5, 2, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nWhat happens if you apply your original `my_mean()` function to this vector?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean(c(4, 5, 2, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.00 1.25 0.50 0.25\n```\n\n\n:::\n:::\n\n\nThis is equivalent to assigning the argument `a = c(4, 5, 2, 1)`, and then not providing any values for the `b`, `c`, and `d` arguments (so their default values are used). So the above code is equivalent to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (a + b + c + d) / 4\n\n(c(4, 5, 2, 1) + 0 + 0 + 0) / 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.00 1.25 0.50 0.25\n```\n\n\n:::\n:::\n\n\nThe fact that we haven't told any of our functions what type of object the arguments should be means that the function will simply take whatever object it is given and try and run the code. In the next lesson, you will learn how to specify options for arguments using if/else statements and by providing several argument defaults. \n\n\n \n## If/else statements\n\nFirst, let's explain what an if statement and an if/else statement is. \n\n### If statements\n\nLet's start with a stand-alone \"if\" statement.\n\nThe following code defines a variable `a`, and then runs some *conditional* code that is only run if the condition `a == 1` is `TRUE`. In this case, since `a` contains the value `5`, the condition `a == 1` is `FALSE`, and so the code `\"a is 1\"` is not run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 5\n\nif (a == 1) {\n  \"a is 1\"\n}\n```\n:::\n\n\n\nIf instead, we assign `a` to `1`, then the code `\"a is 1\"` will be run:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\n\nif (a == 1) {\n  \"a is 1\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a is 1\"\n```\n\n\n:::\n:::\n\n\nThere is nothing special about the string value provided, it is just a simple piece of code. We could instead just run code containing a numeric value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\n\nif (a == 1) {\n  3\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nOr even define a variable inside our \"if\" statement:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\n\nif (a == 1) {\n  y <- 3\n}\n```\n:::\n\n\nNote that unlike for a function, this variable will have been defined in our \"global\" environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n### Else statemenets\n\nWhile you can use a stand-alone \"if\" statement, you can also provide an \"else\" statement. The \"else\" part of the \"if/else\" statement provides some code that will be run if the \"if\" condition is *not* `TRUE`. For example, the following code will first ask if `a` equals 1, and if so, will assign `y <- 3`. If not, the statement will not run the `y <- 3` code and will instead assign `y <- 9`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 3\nif (a == 1) {\n  # if condition is true, run the following:\n  y <- 3\n} else {\n  # if condition is not true, run the following:\n  y <- 9\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# check what y was assigned to\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\n\n\n### Using \"if\" statements to provide custom errors when inappropriate arguments are provided \n\nThe following uses an \"if\" statement to add a \"stop condition\" that throws an error when the argument `a` is either non-numeric or does not have a length of 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean <- function(a = 0, b = 0, c = 0, d = 0) {\n  if (!is.numeric(a) | (length(a) != 1)) {\n    stop(\"'a' must be a numeric value of length 1\")\n  }\n  \n  return((a + b + c + d) / 4)\n}\n```\n:::\n\n\n\n\n### Exercise \n\n\n1. Use an if/else statement that checks whether the value in a variable called `age` is at least 18. If so, your statement should return the character value of \"You are eligible to vote\" and if not, your statement should return \"You are not eligible to vote\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 21\nif (age >= 18) {\n  \"You are eligible to vote\"\n} else {\n  \"You are not eligible to vote\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"You are eligible to vote\"\n```\n\n\n:::\n:::\n\n\n\n2. Write a function that computes the area of a circle (`area = pi * radius^2`) given the radius as its argument and throws an error if a non-numeric or a negative radius value is given.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle_area <- function(radius) {\n  if (!is.numeric(radius) | radius < 0) {\n    stop(\"'radius' must be a non-negative numeric value\")\n  }\n  area <- pi * radius^2\n  return(area)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the following should throw an error:\ncircle_area(\"4\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in circle_area(\"4\"): 'radius' must be a non-negative numeric value\n```\n\n\n:::\n\n```{.r .cell-code}\ncircle_area(-4)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in circle_area(-4): 'radius' must be a non-negative numeric value\n```\n\n\n:::\n:::\n\n\n\n\n## Default argument options\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy <- function(x = 1, y = 1, output_type = c(\"numeric\", \"character\")) {\n  # this line will set the default value of output_type to be \"numeric\"\n  # and will only allow options provided in the default vector\n  output_type <- match.arg(output_type)\n  \n  # stop condition if x or y are not numeric\n  if (!is.numeric(x) | !is.numeric(y)) {\n    stop(\"'x' and 'y' must be numeric\")\n  }\n  \n  # computing my result\n  result <- x + 2 * y\n  \n  # returning result in the format specified by output_type\n  if (output_type == \"numeric\") {\n    return(result)\n  } else if (output_type == \"character\") {\n    return(as.character(result))\n  }\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(x = 2, y = 3, output_type = \"character\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_xy(2, 3, output_type = \"charcter\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in match.arg(output_type): 'arg' should be one of \"numeric\", \"character\"\n```\n\n\n:::\n:::\n\n\n\n### Exercise\n\nWrite a function called `calculate_area()` that will calculate the area of the shape specified in the argument `shape`, which has options \"circle\", \"square\", and \"triangle\". Your function will need to have the following additional arguments: \n\n- `radius` for computing the area of a circle (pi * radius^2), \n\n- `side` for computing the area of a square (side^2), \n\n- `base` and `height` for computing the area of a triangle (height * base / 2). \n\nRecall that arguments that are not *always* required should have a default value. Your function should throw an error when you fail to provide the arguments that are needed for the value specified in the `shape` argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_area <- function(shape = c(\"circle\", \"square\", \"triangle\"),\n                           radius = NA,\n                           side = NA,\n                           base = NA,\n                           height = NA) {\n  shape = match.arg(shape)\n  # error statements\n  if (shape == \"circle\" & is.na(radius)) {\n    stop(\"'radius' required for 'circle' shape\")\n  } \n  if (shape == \"square\" & is.na(side)) {\n    stop(\"'side' required for 'square' shape\")\n  }\n  if (shape == \"triangle\" & (is.na(base) | is.na(height))) {\n    stop(\"'base' and 'height' required for 'triangle' shape\")\n  }\n  \n  # compute the area\n  if (shape == \"circle\") {\n    area <- pi * radius^2\n  } else if (shape == \"square\") {\n    area <- side^2\n  } else if (shape == \"triangle\") {\n    area <- base * height / 2\n  }\n  \n  return(area)\n  \n}\n```\n:::\n\n\n\n\n## Tidy evaluation for writing tidyverse-style functions\n\nSometimes you want to write a function whose argument is a column of a data frame without quotes (i.e., in the tidyverse style) so that you can use it in a tidyverse function. Unfortunately this is more complicated than it should be, but in this lesson, you'll learn how to implement \"tidy evaluation\" so that your function can take tidyverse-style column-name arguments to use in tidyverse functions.\n\nFirst, we have to load in the tidyverse. And we will also load in the demographics data file from the NHANES study. You will need to make sure that your data/ folder and demographics.csv file are saved in the same location as this quarto document, and that your working directory is appropriate (if not, you can choose Session > Set Working Directory > To Source File Location). If you're using a project, then your working directory should already be set to the correct location.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\ndemographics <- read_csv(\"data/demographics.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10175 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): interview_examination, gender, race, marital_status, pregnant\ndbl (9): respondent_id, age_years, age_months_sc_0_2yr, six_month_period, ag...\nlgl (5): served_active_duty_us, served_active_duty_foreign, born_usa, citize...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(demographics)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 19\n  respondent_id interview_examination gender age_years age_months_sc_0_2yr race \n          <dbl> <chr>                 <chr>      <dbl>               <dbl> <chr>\n1         73557 both interview and e… male          69                  NA black\n2         73558 both interview and e… male          54                  NA white\n3         73559 both interview and e… male          72                  NA white\n4         73560 both interview and e… male           9                  NA white\n5         73561 both interview and e… female        73                  NA white\n6         73562 both interview and e… male          56                  NA mexi…\n# ℹ 13 more variables: six_month_period <dbl>, age_months_ex_0_19yr <dbl>,\n#   served_active_duty_us <lgl>, served_active_duty_foreign <lgl>,\n#   born_usa <lgl>, citizen_usa <lgl>, time_in_us <dbl>, education_youth <dbl>,\n#   education <dbl>, marital_status <chr>, pregnant <chr>,\n#   language_english <lgl>, household_income <dbl>\n```\n\n\n:::\n:::\n\n\nSo a reminder of the kinds of things we will often do within the tidyverse is creating figures, such as boxplots, using ggplot2 based on a data frame. Notice that when we refer to the variables from our data frame in the context of the tidyverse (including ggplot2), we do *not* use quotes around the column names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> ggplot() +\n  geom_boxplot(aes(x = served_active_duty_us,\n                   y = age_years))\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nHere is another example using a different variable from the data (`language_english`), where we also add a \"classic\" theme, and some custom axis labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> ggplot() +\n  geom_boxplot(aes(x = language_english,\n                   y = age_years)) + \n  theme_classic() +\n  labs(x = \"English language\",\n       y = \"Age (years)\")\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\nLet's try and turn this into a function so we can create boxplots comparing the age distribution across all of the levels of any categorical varaible in our data that we like without having to copy-and-paste the code over and over again.\n\nIn this first attempt, we use `variable_name` as the argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots <- function(variable_name) {\n  demographics |> ggplot() +\n    geom_boxplot(aes(x = variable_name,\n                     y = age_years)) \n}\n```\n:::\n\n\nBut this yields an error where R claims that it doesn't know what `language_english` is. Which to be fair, since it isn't the name of a variable in our space, it doesn't!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(language_english)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `geom_boxplot()`:\n! Problem while computing aesthetics.\nℹ Error occurred in the 1st layer.\nCaused by error:\n! object 'language_english' not found\n```\n\n\n:::\n:::\n\n\nWe can try and run it with a character/string verion of the column name by wrapping it in quotes, but then we just get one boxplot for the string value `\"language_english\"`, which ggplot doesn't know is supposed to be a column from our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(\"language_english\")\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\nThe issue is that ggplot wants us to refer to the column names without strings, but our custom function doesn't know how to find our column name variable that we provide. \n\nFortunately, there is an easy fix, which involves something called \"tidy evaluation\", which involves wrapping the argument inside two sets of curly parentheses inside the body of our function, which indicates to R that this argument should be used in the tidyverse style, without quotes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots <- function(variable_name) {\n  demographics |> ggplot() +\n    geom_boxplot(aes(x = {{ variable_name }},\n                     y = age_years)) \n}\n```\n:::\n\n\nAnd now it works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(language_english)\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n\n\nLet's use our function on a few different columns to make sure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(marital_status)\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\nNotice that in the marital status plot, the x-axis tick labels are all smooshed into eachother. We deal with this by adding a theme layer to our plot which modifies the properties of the `axis.text.x` theme element. We can add this either to output of `createBoxplots()` (which outputs a ggplot2 object itself):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(marital_status) + \n  theme(axis.text.x = element_text(angle = 90, \n                                   hjust = 1, \n                                   vjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\nOr we can apply it to all plots created with our `createBoxplot()` function by including it in the function body:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots <- function(variable_name) {\n  demographics |> ggplot() +\n    geom_boxplot(aes(x = {{ variable_name }},\n                     y = age_years)) + \n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 90, \n                                   hjust = 1, \n                                   vjust = 0.5))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# now this version will have the 90-degree axis text\ncreateBoxplots(marital_status) \n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n\n#### Adding labels using column variable names\n\nSometimes you want to take the name of the column name that you are providing in the argument and use the actual text from the column name to create a nice label. The last line in the version of our function below converts the `variable_name` to a text-based object and uses the `str_replace` function from the tidyverse to replace the underscore with a space:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots <- function(variable_name) {\n  demographics |> ggplot() +\n    geom_boxplot(aes(x = {{ variable_name }},\n                     y = age_years)) + \n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 90, \n                                   hjust = 1, \n                                   vjust = 0.5)) +\n    labs(x = str_replace(as_label(enquo(variable_name)), \"_\", \" \"),\n         y = \"Age (years)\") \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateBoxplots(marital_status)\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\n#### Tip: Using patchwork to patch together plots\n\nThe patchwork library can be used to create custom grids of ggplot objects (be sure to expand your plot window if the plots aren't showing up properly):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\ncreateBoxplots(language_english) + createBoxplots(marital_status)\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(createBoxplots(language_english) + createBoxplots(marital_status)) / createBoxplots(pregnant)  \n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\n\n### Exercise\n\nCreate a function called createOrderedBars() that takes a categorical column from `demographics` as its argument and creates a bar chart for the average age for each level of the variable. \n\nChallenge mode: Arrange the bars in ascending order, and provide an argument called `ascending` that allows the user to specify whether or not the bars will be arranged in ascending order.\n\n\n\n#### Solution\n\nNote that you'll want to use `geom_col()` instead of `geom_bar()` to create bar charts where the bars have the specific height provided in the y-variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateOrderedBars <- function(variable_name) {\n  demographics |> \n    # group by the column provided\n    group_by({{ variable_name }}) |>\n    # compute the mean age\n    summarize(mean_age = mean(age_years)) |>\n  # create the bar plot\n    ggplot() +\n    geom_col(aes(x = {{ variable_name }}, \n                y = mean_age))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateOrderedBars(marital_status)\n```\n\n::: {.cell-output-display}\n![](09_custom_functions_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n\n#### Challenge solution\n\nTo arrange the bars in ascending order of `mean_age`, you first need to convert the categorical variable itself to a factor whose levels are in the order that you want the bars to appear. You can do this by arranging the rows of your data frame in order of `mean_age` and then using `fct_inorder()` to convert your variable to a factor with levels match the increasing order of `mean_age`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreateOrderedBars <- function(variable_name) {\n  demographics |> \n    # group by the column provided\n    group_by({{ variable_name }}) |>\n    # compute the mean age\n    summarize(mean_age = mean(age_years)) |>\n\n    # OPTIONAL CODE FOR CHALLENGE MODE:\n    # arrange in increasing order of mean_age \n    arrange(mean_age) |>\n    # modify selected_variable so that it is a factor whose levels are in \n    # increasing order of mean_age  \n    mutate(selected_variable = fct_inorder({{ variable_name }})) |>\n    \n  # create the bar plot\n    ggplot() +\n    geom_col(aes(x = selected_variable, \n                y = mean_age))\n}\n```\n:::\n",
    "supporting": [
      "09_custom_functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}