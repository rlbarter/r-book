{
  "hash": "d9909e236f38517d93ea7c83cf51530b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Defining variables\"\nauthor: \"Rebecca Barter\"\nformat: live-html\neditor_options: \n  chunk_output_type: console\nembed-resources: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\nOne of the main features of coding in R is defining \"objects\" or \"variables\" (I use these terms interchangeably). When we are ready to load some data, you will store it in a variable.\n\n\n## Defining variables\n\nLet's define a variable that we will call `my_variable`, and assign it the value 1. \n\nTo define `my_variable`, we can use the **assignment operator** `<-`. This is like an arrow, pointing from the value to the variable name on the left.   \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign the value 1 to the variable x\nmy_variable <- 1 \n```\n:::\n\n\n\n\n\n\nWe can view the value of `my_variable` by writing it's name:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# view my_variable\nmy_variable\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nI can now use the object `my_variable` as an alias for the value `1`. This means that anything I could do to `1`, I can now do to `my_variable` such as adding `2` to it:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_variable + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nBut R is very particular, which means that I must write my variable name exactly as it is written. For example, the following will yield an error:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_Variable\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'my_Variable' not found\n```\n\n\n:::\n:::\n\n\n\n\n\n\nbecause the variable is called `my_variable`, not `my_Variable`. \n\nIn general, a good variable name is human-readable, descriptive, and contains underscores to separate words. We'll talk more about this later when we create some more interesting variables than just the value `1`.\n\n\n\n\n\n\nNote that another way to assign a value to a variable is using \"=\". Below, I create `another_variable`, assign it the value `3`, and print it out, all in the same code chunk:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanother_variable = 3\nanother_variable \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nBut convention in the R community prefers the use of the `<-` assignment operator over the `=` assignment operator. So while, `=` will work just fine, it is a lot less common amongst seasoned R programmers.\n\nWe've seen that we can do math with variables that contain numbers, but it turns out that you can also assign the *output* of mathematical calculations to a variable.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign the output of 1 + 1 to the variable one_plus_one\none_plus_one <- 1 + 1\n# view one_plus_one\none_plus_one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that it is important to make the distinction that `one_plus_one` does not contain the mathematical *equation* `1 + 1`, it contains the number `2`, which is the *output* of the equation `1+1`. `one_plus_one` doesn't remember that it was created by computing `1 + 1`, it just knows that the value it contains is `2`.\n\n\n\n\n::: {.callout}\n\n## Exercise\n\nDefine a new object `prod` that contains the output of the product of 5 and 2. Print out `prod` by writing its name\n\n\n\n\n\n\n\n::: {.cell exercise='ex-prod'}\n```{webr}\n#| exercise: ex-prod\n\n```\n:::\n\n::: {.cell exercise='ex-prod' check='true'}\n```{webr}\n#| exercise: ex-prod\n#| check: true\nif (identical(.result, 5 * 2) & exists(\"prod\")) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n## Overwriting variables\n\n\nBelow I define `my_number` to be a variable containing the numeric value `5`.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_number <- 5\n```\n:::\n\n\n\n\n\n\nNext, I define a new variable called `result`, that contains the product of `my_number` and `7`, and I print it out:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- my_number * 7\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nSo `result` is defined based on the value of `my_number`. What do you think would happen to `result` if I update `my_number` to now contain `8`?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# update the value of my_number to be 8\nmy_number <- 8\n```\n:::\n\n\n\n\n\n\nDo you think `result` will have changed? Type `result` into the box below to see if its value has changed (it was equal to `35` before):\n\n\n\n\n\n\n\n\n::: {.cell exercise='ex-prod'}\n```{webr}\n#| exercise: ex-prod\n\n```\n:::\n\n::: {.cell exercise='ex-prod' check='true'}\n```{webr}\n#| exercise: ex-prod\n#| check: true\nif (identical(.result, result)) {\n  list(correct = TRUE, message = \"It hasn't changed!\")\n} else {\n  list(correct = FALSE, message = \"Hmmm... `result` shouldn't have changed! Try again\")\n}\n```\n:::\n\n\n\n\n\n\n\n\nRecall that when we defined `result <- my_number * 7`, we assigned result to the *output* of `my_number * 7`, which is 56. Once it has been defined, `result` forgets all about `my_number`. This means that changing `my_number` *after* having defined `result` will have no effect on `result`. There is no link between the two variables, despite the fact that `result` was defined using `my_number`!\n\n\n\n\n\n\n\n::: {.callout}\n\n## Exercise\n\nGuess what the output of the following code chunk will be:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalue <- 1\ncomputed_result <- value * 10 + 3^2\nvalue <- value + 2\ncomputed_result * 2 \n```\n:::\n\n\n\n\n\n\nRun it in the code box below to check if your guess was correct:\n\n\n\n\n\n\n::: {.cell exercise='ex-prod'}\n```{webr}\n#| exercise: ex-prod\nvalue <- 1\ncomputed_result <- value * 10 + 3^2\nvalue <- value + 2\ncomputed_result * 2 \n```\n:::\n\n\n\n\n\n\n:::\n\n\n\n\n\n\n\n## Variable names\n\n\nWhile you can give your variables *almost* any name you like, there are a few rules that you need follow. \n\nWhile variable names can contain letters, numbers, underscores, and periods, recommended convention specifies that variable names should contain purely lowercase letters and numbers, with words separated by underscores (not periods). For example, `var_name` and `my_var` are \"good\" variable names, whereas `varName`, `VarName`, and `var.name` are not.\n\nNote that variable names cannot *begin* with numbers or underscores. If you try to create variables whose names are illegal, you will get an error, such as:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1plus1 <- 1 + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:1:2: unexpected symbol\n1: 1plus1\n     ^\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n_var <- 1 + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:1:2: unexpected symbol\n1: _var\n     ^\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n::: {.callout}\n\n## Exercise\n\nWhich of the following are valid R variable names? Which ones are *good* variable names?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_height\nmax.height\n_age\nMaxLength\nmin-length\n2widths\ncelsius2kelvin\n```\n:::\n\n\n\n\n\n\n\n:::\n\n",
    "supporting": [
      "02_variables_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}