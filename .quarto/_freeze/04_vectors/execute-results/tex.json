{
  "hash": "96d8c2004cff77e176a758a72ef23391",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nauthor: \"Rebecca Barter\"\nformat: live-html\nembed-resources: true\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n<!-- <style> -->\n<!--   .draggable-box { -->\n<!--     position: -webkit-sticky; /* Safari */ -->\n<!--     position: sticky; -->\n<!--     top: 50px; -->\n<!--     padding: 10px; -->\n<!--     background-color: #f0f0f0; -->\n<!--     border: 1px solid #ddd; -->\n<!--     border-radius: 4px; -->\n<!--     box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); -->\n<!--     cursor: move; -->\n<!--   } -->\n<!-- </style> -->\n\n\n<!-- <script> -->\n<!--   // Make the DIV element draggable -->\n<!--   dragElement(document.getElementById(\"draggableBox\")); -->\n\n<!--   function dragElement(element) { -->\n<!--     var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; -->\n<!--     element.onmousedown = dragMouseDown; -->\n\n<!--     function dragMouseDown(e) { -->\n<!--       e = e || window.event; -->\n<!--       e.preventDefault(); -->\n<!--       // Get the mouse cursor position at startup: -->\n<!--       pos3 = e.clientX; -->\n<!--       pos4 = e.clientY; -->\n<!--       document.onmouseup = closeDragElement; -->\n<!--       // Call a function whenever the cursor moves: -->\n<!--       document.onmousemove = elementDrag; -->\n<!--     } -->\n\n<!--     function elementDrag(e) { -->\n<!--       e = e || window.event; -->\n<!--       e.preventDefault(); -->\n<!--       // Calculate the new cursor position: -->\n<!--       pos1 = pos3 - e.clientX; -->\n<!--       pos2 = pos4 - e.clientY; -->\n<!--       pos3 = e.clientX; -->\n<!--       pos4 = e.clientY; -->\n<!--       // Set the element's new position: -->\n<!--       element.style.top = (element.offsetTop - pos2) + \"px\"; -->\n<!--       element.style.left = (element.offsetLeft - pos1) + \"px\"; -->\n<!--     } -->\n\n<!--     function closeDragElement() { -->\n<!--       // Stop moving when mouse button is released: -->\n<!--       document.onmouseup = null; -->\n<!--       document.onmousemove = null; -->\n<!--     } -->\n<!--   } -->\n<!-- </script> -->\n\n\n<!-- <div id=\"draggableBox\" class=\"draggable-box\"> -->\n<!-- ```{webr} -->\n<!-- # playspace -->\n<!-- ``` -->\n<!-- </div> -->\n\n\n\n## Introduction to vectors\n\nWhile being able to store numbers and text in an object is neat, such as `x <- 12`, the real power of R is that you can create a wide variety of objects, including an entire dataset, model, or even a data visualization!\n\nHowever, before we try to create an object containing an entire dataset, let's start with just a collection of values, such as might appear in a single column of a dataset.\n\nThe kind of object that contains a collection of values is called a **vector**. Let's create a vector that contains the ages of 5 people:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(12, 19, 22, 35, 18)\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 19 22 35 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that they `[1]` at the beginning of the output is just telling you that the first value is at location 1. If our vector was so long that it would spill onto multiple lines in our output, like this\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_age <- c(12, 19, 22, 35, 18, 44, 23, 56, 23, 12, 18, 19, 50, 60, 77, 54, \n              34, 66, 34, 32, 19, 20, 21, 18, 19, 72, 27, 43, 63, 23, 12, 18, \n              19, 50, 60, 77, 54)\nlong_age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 12 19 22 35 18 44 23 56 23 12 18 19 50 60 77 54 34 66 34 32 19 20 21 18 19\n[26] 72 27 43 63 23 12 18 19 50 60 77 54\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that the second line in the \"output\" has a different number inside the square parentheses. This is just telling you which entry (in terms of its index position) that first entry on the second line is.\n\n\nHere we're technically using a *function*, `c()` to create our vector object. Our `c()` function asks R to take all of the values inside the parentheses of `c()`, which are separated by commas and to combine or \"**c**oncatenate\" them into a single vector object.\n\nYou might think that when we apply `class()` to our `age` vector object, that it would return \"vector\". However, the *type* or *class* of a vector is actually just the *type* or *class* of the values it contains, which in this case, is \"numeric\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis means that if we had created a vector of names, such as the one below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dean\" \"Xiao\" \"Sara\" \"Ravi\" \"Maya\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThen our `names` vector object will have class \"character\":\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nVectors are great. Rather than having to carry around all of my individual numbers and words, I can put them all into a little vector \"bag\" and carry them around together.\n\nHowever, vectors are a little bit particular. Let's try and create a vector that contains multiple different types of values, such as numbers and text:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_vec <- c(1, 9, \"banana\", 10, -1)\nmulti_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"      \"9\"      \"banana\" \"10\"     \"-1\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat class/type do you think this `multi_vec` vector will have? Take a close look at the values in the *output* when we print out the `multi_vec` object itself. Did you notice the quotes around the numbers? Let's check the class of `multi_vec`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(multi_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nInteresting. `multi_vec` is a character vector, despite the fact that most of the values it contains were numbers. This is because vectors can only contain values of a single type. It will let you create a vector using values of multiple different types (such as numbers and characters), but in the actual vector object that is created, all of the values will be *converted* to the same type, in this example, that type was \"character\". \n\nWhat do you think will happen if we try to create a vector with numbers and logical values (`TRUE`/`FALSE`) values? Below I try to combine some numbers with a `TRUE` and a `FALSE` into the same vector. Notice how the ouput when I print the name of the object differs from the object I created:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_vec2 <- c(1, 5, TRUE, FALSE, -9)\nmulti_vec2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  5  1  0 -9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat has happened here? Just like R converted my numbers to a character when a character value was present in the vector, here, R has converted my logical values (my `TRUE` and `FALSE` values) to numbers (corresponding to `1` and `0`, respectively). \n\nHow can you tell what the type of a vector is going to be, when your vector is created using values of various different types? It turns out that there is a hierarchy of types: \n\n<p style=\"text-align:center\">\n**Character > Numeric > Logical**\n</p>\n\nThis doesn't mean that characters are better than numerics which are in turn better than logicals, but rather this means that if a character value is present among the values that define the vector, then all values in the vector will be converted to the character type. If there are no characters being used to define the vector, but there are numeric values and logical values, then all of the values will be converted to the numeric type.\n\n\n\n\n### Exercise\n\nBefore you run the code below, predict what vector will be created from the code below. Consider the type hierarchy above. You can also add some code in the box to check the class of the `vector_example` object.\n\n\n\n\n\n\n::: {.cell autorun='false'}\n```{webr}\n#| autorun: false\nvector_example <- c(TRUE, 4, \"hello\", FALSE, 0)\nvector_example\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Working with vectors: vectorization\n\nWhile it's super neat that we can collect all of our numbers and words in a single vector object (although no mixing of words and numbers please), the actual cool thing about vectors is that it makes it really easy to do computations on all of our values at once.\n\nIf we define our `age` vector below\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n\n\n\n\n\nA really neat property of vectors is that if I subtract `1` from the entire vector, R will subtract `1` from *every value in the vector* at once:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# subtract 1 from age\nage - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 17 21 20 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLet's do something else neat. Let's create an entirely new vector object, that I'm going to creatively call `age2`, which contains the original `age` vector multiplied by 2.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 <- age * 2\n```\n:::\n\n\n\n\n\n\nIf we want to look at what values `age2` contains, we can print out its name and lo and behold, all of the values in `age2` correspond to the original values in `age`, multiplied by 2:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 36 44 42 34\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe fact that when I conduct a mathematical operation on a vector, the mathematical operation will be performed on every individual value in the vector, is called **vectorization**. While it might seem not that cool. It is cool. Trust me. Imagine how tired your fingers would get if you had to subtract `1` from every value in a vector contianing 1000 values. With vectorization I just have to subtract `1` from the vector object itself, and I'm done.\n\n\n\nSo now that we have two age vectors, `age` and `age2`, which are both printed below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nage2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 36 44 42 34\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat do you think will happen if I try to add these two vectors together?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 + age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 36 54 66 63 51\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBecause vectors are *vectorized*, the entries were added *element-wise*. This means that the first value in `age` was added to the first value in `age2`, and similarly for the second value, and so on and so forth.\n\nNote that in the computation above, we printed out the resulting vector, but we did not *save* this vector as an object. The above vector, having been computed, has now been lost to the ether. I can look at the result of `age2` + `age`, but I can't do anything further with it. If I wanted to use this resulting vector for something, I would need to *save* it as a new object (such as `age3 <- age2 + age`).\n\n\n\nSince we can add vectors together, it follows that we can probably also subtract them from one another and multiply them by one another, and all of these operations will happen *element-wise*. For example, we can divide `age2` by `age`, and we will get a vector containing 5 `2`s, because each entry in `age2` is twice the corresponding entry in `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 / age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2 2 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIn this example, both `age` and `age2` have the same *length*. That is, they have the same number of entries. \n\nWhat do you think will happen if we try to do a computation with vectors of different lengths? Let's try to subtract a vector of length 2 (`c(1, 2)`) from `age`, which has length 5:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage - c(1, 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age - c(1, 2): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 16 21 19 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nInterestingly, it worked, but we got a warning message that says \"*longer object length is not a multiple of shorter object length*\". Take a look at the output of the code above. Can you figure out what R did here?\n\nR is being very presumptuous. Without even bothering to ask me, it \"recycled\" the values in the shorter vector, `c(1, 2)`, to match the length of the longer vector, `age`, by repeating the values `1` and `2` until it gets to 5 values in total, so it is essentially doing this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage - c(1, 2, 1, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 16 21 19 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nPersonally, I'd prefer if R gave me an error. But unfortunately for me, I didn't write the R programming language, I just use it. To be fair, R did provide a warning that I was trying to do a computation with vectors of different lengths. But usually when I get this warning, it's because I've made a mistake somewhere. I can guarantee that I pretty much never actually want to do operations with vector of different lengths. \n\nIn summary, my advice is *don't ignore* the warning message \"*longer object length is not a multiple of shorter object length*\". Check your lengths!\n\nSpeaking of \"checking your lengths\", it might be helpful if I told you how to do that! You can compute the length of a vector by applying the `length()` function to it:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n### Vectorized logical operations\n\n\nOk, moving on. Remember when we asked questions about the values that we had stored in our variables/objects, like `x == 1`? Well it turns out that we can ask the same questions of vectors! And, you guessed it, those questions will be asked *element-wise*.\n\nSo if we ask \"which `age` entries are greater or equal to 18\" using the code below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage >= 18\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis question gets asked separately for every entry in `age`. If you need a reminder of what `age` contains, take a look below. The vector above is `TRUE` for the `age` entries that are 18 or above, and is `FALSE` for the `age` entries that are less than 18.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWe can ask all kinds of questions. Like, \"which `age` entries are equal to 17\"?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == 17\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd it looks like only the last one is. \n\n\"Which `age` entries are *not* equal to 21\"?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage != 21\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nWhat if we want to ask which `age` entries are equal to *either* 17 or 18? The natural thing to try is:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == c(17, 18)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age == c(17, 18): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf we take a look at `age` again,\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nOur `age == c(17 18)` looks like it did the correct thing (as in, we got `TRUE` for the second and fifth entries), but it also gives us our trusty \"*longer object length is not a multiple of shorter object length*\" warning message. \n\nIf this works, it should probably also work if we switch the order of 18 and 17 in our question, right?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# switch the order of 17 and 18 in our vector\nage == c(18, 17)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age == c(18, 17): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis time we still get some output, along with our \"longer object length is not a multiple of shorter object length\" warning, but the answer is *wrong*. All of the entries in our resulting output vector are `FALSE`. \n\nThis is because R is doing that pesky recycling thing again. This question is equivalent to:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == c(18, 17, 18, 17, 18)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nAnd the question is being asked element-wise (is the first entry equal to `18`? Is the second entry equal to `17`? Is the third entry equal to `18`?, etc). The only reason we got the correct answer the first time is because we got lucky with our recycling. \n\nAgain, don't forget my advice: *don't ignore* the warning message \"*longer object length is not a multiple of shorter object length*\". Check your lengths!\n\n\n\n### The `%in%` operator\n\nOkay, so if `age == c(17, 18)` isn't how we ask the question of which `age` entries are equal to `17` or `18`, how *do* we ask that question?\n\nYou may have guessed from the subheading above that we are going to use a new operator, `%in%`. To use `%in%`, just replace `==` in the question above, with `%in%`!\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use %in% to ask which entries in age are equal to 17 or 18\nage %in% c(17, 18) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd voila! This time it tells us that the second and fifth entries are equal to either 17 or 18, *and* we didn't get any warning! Yay!\n\n\n\n\n\n\n\n\n## Helpful summarization functions for vectors\n\nSo I showed you earlier that you can use the `length()` function to compute the number of values in a vector, but this is just one of many function that you can use to summarize a vector. \n\n\nFor example, the `sum()` function can be used to add up all the entries in a (numeric) vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 90\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `mean()` function computes the mean/average:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `median()` funciton computes the median:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `var()` function computes the variance:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `sd()` function computes the standard deviation:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.937004\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe function `length()` tells you how many entries the vector contains:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe `min()` function tells you the smallest value:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd the `max` function tells you the biggest value:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nAnd we can even contain some of the super fun logical stuff from above with `sum()` to compute even more interesting summaries. \n\nFirst, note that when you apply `sum()` (or `mean()`) to a vector of logical values, it treats `FALSE` as `0` and `TRUE` as `1`. So when you apply `sum()` to a logical vector, it adds up the number of `TRUE` values:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute the number of TRUE values \nsum(c(TRUE, FALSE, FALSE, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo we can use this to do things like add up the number of values in `age` that are either 17 or 18:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add up the number of age entries that are 17 or 18\nsum(age %in% c(17, 18))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOr add at the number of values in `age` that are strictly greater than 15:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add up the number of age entries that are over 15\nsum(age > 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n### Exercise\n\nIn the box below, try to use the functions above to compute the *proportion* of people whose age is strictly greater than 15\n\n\n\n\n\n\n::: {.cell exercise='ex-prop-vec' setup='true'}\n```{webr}\n#| exercise: ex-prop-vec\n#| setup: true\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n::: {.cell exercise='ex-prop-vec'}\n```{webr}\n#| exercise: ex-prop-vec\n```\n:::\n\n::: {.cell exercise='ex-prop-vec' check='true'}\n```{webr}\n#| exercise: ex-prop-vec\n#| check: true\nif (identical(.result, sum(age > 15) / length(age))) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\n\n\n::::: { .hint exercise=\"ex-prop-vec\"}\n::: { .callout-tip collapse=\"false\"}\n## Hint\n\nConsider using the `sum()` function and the `length()` function.\n\n:::\n:::::\n\n::: { .solution exercise=\"ex-prop-vec\" }\n\n**Solution:**\n\n```r\nsum(age > 15) / length(age)\n```\n:::\n\n\n\n\n\n\n\n\n\n## Extracting information from vectors\n\nWe know how to put out values into a vector (i.e., using `c()`), but how do we get them out again?\n\nTo extract values from a vector, you can type the name of the vector that you want to extract the values from, followed by some square parentheses `[]`, inside which you place the numeric location (index) of the value you want to extract.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# let's quickly remind ourselves of what values age contains\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nFor example, if you want to extract the first entry from `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nGo ahead and try to extract the fourth entry from `age`:\n\n\n\n\n\n\n\n::: {.cell exercise='ex-extract-4' setup='true'}\n```{webr}\n#| exercise: ex-extract-4\n#| setup: true\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n::: {.cell exercise='ex-extract-4'}\n```{webr}\n#| exercise: ex-extract-4\n\n```\n:::\n\n::: {.cell exercise='ex-extract-4' check='true'}\n```{webr}\n#| exercise: ex-extract-4\n#| check: true\nif (identical(.result, age[4])) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\nIf you want to extract the final entry in a vector and you don't immediately know it's length, you can do something clever like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[length(age)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhy does this work? Remember that `length(age)` tells you how many values there are in `age` (5), and so this is equivalent to `age[5]`, which will extract the final value from the `age` vector.\n\n\n\n\n### Removing a value from a vector\n\nIf I wanted to *extract* the first entry from `age`, I would write, `age[1]`. This is actually essentially creating a new vector that just consists of the first value in `age`.\n\nIf I wanted to instead create a new vector that *removed* this first entry, I would write\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove the first entry from age\nage[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf `age[1]` *extracts* the first entry from `age`, `age[-1]` *removes* the first entry from age.\n\nKeep in mind, none of these operations so far have changed the original `age` object:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhen I run `age[1]`, the output is just the result of extracting the first entry from `age`, but I am not saving this result, nor am I overwriting our `age` vector with this value. If I wanted to do that I would write `age <- age[1]`--then `age` would only contain this first value. Remember that the output of your code is only saved when you assign the result of the computation to something using `<-`!\n\n\nTry to demonstrate what would happen if you removed the fourth entry from `age`:\n\n\n\n\n\n\n\n\n::: {.cell exercise='ex-remove-4' setup='true'}\n```{webr}\n#| exercise: ex-remove-4\n#| setup: true\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n::: {.cell exercise='ex-remove-4'}\n```{webr}\n#| exercise: ex-remove-4\n\n```\n:::\n\n::: {.cell exercise='ex-remove-4' check='true'}\n```{webr}\n#| exercise: ex-remove-4\n#| check: true\nif (identical(.result, age[-4])) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n### Extracting/removing multiple entries from a vector\n\nSo far we have just extracted and removed a single entry from `age` at a time. Let's quickly remind ourselves of what `age` contains:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nBut often, we want to be able to extract or remove multiple entries at once. That is, I want to provide multiple values inside my square parentheses `[ ]`, but they only accept one value! If I try to provide two values inside my `[ ]` parentheses, I get an error. For example, below, I try to extract both the first and third entries (12 and 22) from `age` at once by just providing two numbers inside the square parentheses:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1, 3]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in age[1, 3]: incorrect number of dimensions\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut I got an error :'(. The error \"incorrect number of dimensions\" is telling me that it only wants one object, not two inside the square parentheses!\n\nSo I need to provide two position values (1 and 3), but I can only provide one object inside. How could I create *one* object that contains *two* values? One object... two values... Hmmmmmmmm. Have you figured it out yet? Why don't you put the two values inside a *vector*! Wow! Neat idea!\n\n\nLet's try and extract the first and third entries from `age` at once, by providing a vector `c(1, 3)` inside the square parentheses:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt worked!\n\nMaybe we can also remove the first and third entries by providing the negative of this vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[-c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat worked too! Vectors are great. \n\n\n\n\n\n\n\n\n\n\n## Definining integer sequences\n\nWhat if you wanted to define a really long vector like:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_long_vector <- c(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, \n                    111, 112, 113, 114, 115, 116, 117, 118, 119, 120, \n                    121, 122, 123, 124, 125, 126, 127, 128, 129, 130, \n                    131, 132, 133, 134, 135, 136, 137, 138, 139, 140, \n                    141, 142, 143, 144, 145, 146, 147, 148, 149, 150, \n                    151, 152, 153, 154, 155, 156, 157, 158, 159, 160, \n                    161, 162, 163, 164, 165, 166, 167, 168, 169, 170, \n                    171, 172, 173, 174, 175, 176, 177, 178, 179, 180, \n                    181, 182, 183, 184, 185, 186, 187, 188, 189, 190, \n                    191, 192, 193, 194, 195, 196, 197, 198, 199, 200)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_long_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118\n [19] 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136\n [37] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154\n [55] 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172\n [73] 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190\n [91] 191 192 193 194 195 196 197 198 199 200\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWriting this out made my fingers really tired. And if you're learned anything about me so far, you'll know how much I hate it when my fingers get tired. \n\nFortunately, there's a better way. If I want to define a vector containing squence of integers like in `my_long_vector`, I can use the `:` syntax. For example, to create the vector `c(1, 2, 3, 4)`, I could write:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that I haven't saved this vector (I just wrote the code to create it and then the result was printed and lost to the universe after that), but I could if I wanted to. Below, I save the above vector in an object called `vector1to4`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1to4 <- 1:4\n```\n:::\n\n\n\n\n\n\nAnd then I can access this vector by writing its name:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1to4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe syntax to create a sequential vector of integers is `start:stop`. So if `1:4` created the vector `c(1, 2, 3, 4)`, how might you create the long vector that I saved in `my_long_vector` above? Well the starting value is 101 and the last (stop) value is 200, so maybe we can try `101:200`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n101:200\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118\n [19] 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136\n [37] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154\n [55] 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172\n [73] 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190\n [91] 191 192 193 194 195 196 197 198 199 200\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPerfecto!\n\n\nThe cool thing about this is that we can use it to *extract* segments of a vector, for instance, to extract the first four entries of `age`, we could write\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Logical subsetting {#sec-logical-subsetting}\n\nSometimes you might want to extract all the entries from a vector that satisfy a certain condition. To do that, you first need to understand how you can use a logical vector to extract values. \n\nIf I provide a vector of `TRUE`s and `FALSE`s inside the square parentheses, R will extract all of the values whose position in the logial vector have a `TRUE`.\n\nFor example, the following code will extract the first, fourth, and fifth entries:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(TRUE, FALSE, FALSE, TRUE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nOk. So I would never actually write out such a vector, because I have a life, *BUT* do you remember earlier when we asked logical questions of our vectors, such as, which entries in `age` are greater than or equal to 18:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage >= 18\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWell this created a logical vector for us *AND* the `TRUE` values correspond to the values in the vector for which the condition is true. Do you see where I'm going with this?\n\nIf you want to extract all of the values in a vector for which a logical condition is true, you can provide the logical condition inside the square parentheses of the vector!\n\nThe following code will extract the values in `age` that are all greater or equal to 18:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[age >= 18]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThis is great for simple conditions, but what about more complex conditions, such as ages that are at least 17 but less than 20. Unfortunately, the mathematical syntax for $17 \\leq x \\leq 20$ doesn't work in R:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n17 <= age < 20\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:1:11: unexpected '<'\n1: 17 <= age <\n              ^\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, we can combine multiple conditions in R, using `|` if we want either condition to be true (the logical \"OR\") and `&` for if we want both conditions to be true (the logical \"AND\").\n\nThe condition that the age is at least 17 but less than 20 is the combination of the two conditions `age >= 17` and `age < 20`, and we need both of these things to be true, so we can write\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# age at least 17 and less than 20\n(age >= 17) & (age < 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf both conditions are `TRUE`, then the output of `condition 1 & condition 2` will be `TRUE`, but if either one of `condition 1` or `condition 2` is `FALSE` then the output  of `condition 1 & condition 2` will be `FALSE`\n\nAnd we can use this \"AND\" condition to *extract* all of the entries in `age` that are both greater or equal to 17 AND less than 20.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract all of the ages that are both >= 17 and < 20\n(age >= 17) & (age < 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `|` \"OR\" operator, however will be `TRUE` if either condition in `condition 1 | condition 2` is `TRUE` (even if the other one is `FALSE`).\n\n\nSo for example, the ages that are EITHER less than or equal to 16 OR greater than 20 are the first, third, and fourth. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(age <= 16) | (age > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd we can use this \"OR\" condition to *extract* all of the entries in `age` that are either less than 16 or greater than 20.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract all of the ages that are either <= 16 or > 20\nage[(age <= 16) | (age > 20)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSorry if your brain hurts. \n\n\n\n## Exercise\n\nLet's practice a little. Here is a new vector, `vec`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(4, 19, 2, 2, 3, 90, 55, 12)\n```\n:::\n\n\n\n\n\n\nIn the box below, extract the entries that are less than 10\n\n\n\n\n\n\n\n::: {.cell exercise='ex-logical1' setup='true'}\n```{webr}\n#| exercise: ex-logical1\n#| setup: true\nvec <- c(4, 19, 2, 2, 3, 90, 55, 12)\n```\n:::\n\n::: {.cell exercise='ex-logical1'}\n```{webr}\n#| exercise: ex-logical1\n\n```\n:::\n\n::: {.cell exercise='ex-logical1' check='true'}\n```{webr}\n#| exercise: ex-logical1\n#| check: true\nif (identical(.result, vec[vec < 10])) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\nIn the box below, extract the entries that are less than 25 but greater than 10\n\n\n\n\n\n\n\n::: {.cell exercise='ex-logical2' setup='true'}\n```{webr}\n#| exercise: ex-logical2\n#| setup: true\nvec <- c(4, 19, 2, 2, 3, 90, 55, 12)\n```\n:::\n\n::: {.cell exercise='ex-logical2'}\n```{webr}\n#| exercise: ex-logical2\n\n```\n:::\n\n::: {.cell exercise='ex-logical2' check='true'}\n```{webr}\n#| exercise: ex-logical2\n#| check: true\nif (identical(.result, vec[(vec < 25) & (vec > 10)])) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\n\nIn the box below, extract the entries that are either less than 10 or equal to 55\n\n\n\n\n\n\n\n::: {.cell exercise='ex-logical2' setup='true'}\n```{webr}\n#| exercise: ex-logical2\n#| setup: true\nvec <- c(4, 19, 2, 2, 3, 90, 55, 12)\n```\n:::\n\n::: {.cell exercise='ex-logical2'}\n```{webr}\n#| exercise: ex-logical2\n\n```\n:::\n\n::: {.cell exercise='ex-logical2' check='true'}\n```{webr}\n#| exercise: ex-logical2\n#| check: true\nif (identical(.result, vec[(vec < 10) | (vec == 55)])) {\n  list(correct = TRUE, message = \"Nice work!\")\n} else {\n  list(correct = FALSE, message = \"Not quite--Try again!\")\n}\n```\n:::\n\n\n\n\n\n\n\n\n\n## Named vectors\n\nBefore we move on to working with actual data (*finally*!) I just want to show you one final thing about vectors, and that is that you can give each entry in a vector its own name.\n\nLet's remind ourself of what our trust `age` vector contains:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf we wanted each entry in `age` to have it's own name, we could use the `names()` function. Since `names(age)` extracts an attribute of `age` (it's names, which are currently nonexistent), by assigning `names(age)` to something, we can update the names.\n\nBelow, we update the names of the entries in `age` to be \"Dean\", \"Xiao\", \"Sara\", \"Ravi\", and \"Maya\", respectively. Note that this *does* modify the `age` object directly (specifically, it modifies the *names* of age through assignment `<-`):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add the names \"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\" to the age vector\nnames(age) <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDean Xiao Sara Ravi Maya \n  12   18   22   21   17 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhile you can define a vector and then update its names later, you can alternatively create the names when you actually create the vector using the syntax below.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(\"Dean\" = 12, \"Xiao\" = 18, \"Sara\" = 22, \"Ravi\" = 21, \"Maya\" = 17)\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDean Xiao Sara Ravi Maya \n  12   18   22   21   17 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nTake a look at the output of this \"named vector\". How does it look different to the original unnamed `age` vector? The name for each entry appears above the value, and the `[1]` at the beginning of the vector that denotes the first entry is gone! I have no explanation for this.\n\nThe cool thing about named vectors is that you can extract an entry from a vector using its name. For example, if I just wanted Ravi's age, I could write:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[\"Ravi\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRavi \n  21 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that the name of the vector must be a character string, i.e., I have to have quotes around `\"Ravi\"`.\n\nI can also extract several entries from the vector using a vector of the names I want, just as I did with numbers representing the index positions I wanted to extract:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(\"Maya\", \"Ravi\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaya Ravi \n  17   21 \n```\n\n\n:::\n:::\n",
    "supporting": [
      "04_vectors_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}