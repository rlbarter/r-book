{
  "hash": "4637e2ad6bd9091bf5d7f1a27f4ee410",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recoding variables using if_else and case_when\"\nformat: html\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\ndemographics <- read_csv(\"data/demographics.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10175 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): interview_examination, gender, race, marital_status, pregnant\ndbl (9): respondent_id, age_years, age_months_sc_0_2yr, six_month_period, ag...\nlgl (5): served_active_duty_us, served_active_duty_foreign, born_usa, citize...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndemographics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,175 × 19\n   respondent_id interview_examination   gender age_years age_months_sc_0_2yr\n           <dbl> <chr>                   <chr>      <dbl>               <dbl>\n 1         73557 both interview and exam male          69                  NA\n 2         73558 both interview and exam male          54                  NA\n 3         73559 both interview and exam male          72                  NA\n 4         73560 both interview and exam male           9                  NA\n 5         73561 both interview and exam female        73                  NA\n 6         73562 both interview and exam male          56                  NA\n 7         73563 both interview and exam male           0                   5\n 8         73564 both interview and exam female        61                  NA\n 9         73565 interview only          male          42                  NA\n10         73566 both interview and exam female        56                  NA\n# ℹ 10,165 more rows\n# ℹ 14 more variables: race <chr>, six_month_period <dbl>,\n#   age_months_ex_0_19yr <dbl>, served_active_duty_us <lgl>,\n#   served_active_duty_foreign <lgl>, born_usa <lgl>, citizen_usa <lgl>,\n#   time_in_us <dbl>, education_youth <dbl>, education <dbl>,\n#   marital_status <chr>, pregnant <chr>, language_english <lgl>,\n#   household_income <dbl>\n```\n\n\n:::\n:::\n\n\n\nIn this document, you will learn how to \"recode\" variables by replacing values in a variable with other values of your choice. The most common use-case is typically converting numerically-encoded variables to categorical/character versions, and vice versa. \n\nWe will introduce two functions for doing this: \n\n- `if_else()` which can be used to create binary variables (variables with just two distinct values) based on a logical \"condition\"\n\n- `case_when()` which can be used to create variables with many different values.\n\n## if_else\n\nConsider, for example, the `interview_examination` column. This variable has two distinct values `\"both interview and exam\"` and `\"interview only\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> count(interview_examination)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  interview_examination       n\n  <chr>                   <int>\n1 both interview and exam  9813\n2 interview only            362\n```\n\n\n:::\n:::\n\n\nIf we wanted to do an analysis involving this column, we might need to convert it to a numeric format. We can do that using `if_else()`. The code below uses `if_else()` to create a column called `interview_examination_numeric` that converts all values in `interview_examination` that are equal to `\"both interview and exam\"` to `2`, and converts all other values to `1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> \n  mutate(interview_examination_numeric = if_else(interview_examination == \"both interview and exam\", \n                                                 true = 2, \n                                                 false = 1)) |>\n  select(interview_examination, interview_examination_numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,175 × 2\n   interview_examination   interview_examination_numeric\n   <chr>                                           <dbl>\n 1 both interview and exam                             2\n 2 both interview and exam                             2\n 3 both interview and exam                             2\n 4 both interview and exam                             2\n 5 both interview and exam                             2\n 6 both interview and exam                             2\n 7 both interview and exam                             2\n 8 both interview and exam                             2\n 9 interview only                                      1\n10 both interview and exam                             2\n# ℹ 10,165 more rows\n```\n\n\n:::\n:::\n\n\nNote that you can use `if_else()` for columns of any type. The following code again creates the `interview_examination_numeric` column, and then creates a new column called `interview_examination_revert` that takes the numeric encoding and converts the values `2` and `1` to new character values, `\"both\"` and `\"just interview\"`, respectively. We also use the select helper `contains()` inside our select function to view all of the resulting columns that contain the word `\"interview\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> \n  mutate(interview_examination_numeric = if_else(interview_examination == \"both interview and exam\", \n                                                 true = 2, \n                                                 false = 1)) |>\n  mutate(interview_examination_revert = if_else(interview_examination_numeric == 2,\n                                                true = \"both\",\n                                                false = \"just interview\")) |>\n  select(contains(\"interview\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,175 × 3\n   interview_examination   interview_examination_numeric interview_examination…¹\n   <chr>                                           <dbl> <chr>                  \n 1 both interview and exam                             2 both                   \n 2 both interview and exam                             2 both                   \n 3 both interview and exam                             2 both                   \n 4 both interview and exam                             2 both                   \n 5 both interview and exam                             2 both                   \n 6 both interview and exam                             2 both                   \n 7 both interview and exam                             2 both                   \n 8 both interview and exam                             2 both                   \n 9 interview only                                      1 just interview         \n10 both interview and exam                             2 both                   \n# ℹ 10,165 more rows\n# ℹ abbreviated name: ¹​interview_examination_revert\n```\n\n\n:::\n:::\n\n\n### Exercise\n\nUse `if_else()` to create a variable called `completed_high_school`, which has the values `\"yes\"` if `education` is equal to at least 3, and `\"no\"` otherwise.\n\nA link to the documentation for the demographics data can be found [here](https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_DEMO.htm#DMDEDUC2).\n\n\n#### Solution\n\nOur condition is `education >= 3` and we want to replace all values for which this condition is true with `\"yes\"`, and all other values with `\"no\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> \n  mutate(completed_high_school = if_else(education >= 3, true = \"yes\", false = \"no\")) |>\n  select(education, completed_high_school) |>\n  sample_n(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   education completed_high_school\n       <dbl> <chr>                \n 1         3 yes                  \n 2         5 yes                  \n 3         4 yes                  \n 4        NA <NA>                 \n 5         3 yes                  \n 6        NA <NA>                 \n 7         3 yes                  \n 8        NA <NA>                 \n 9        NA <NA>                 \n10         1 no                   \n```\n\n\n:::\n:::\n\n\n\n## case_when\n\nThe `case_when()` function is similar to `if_else()`, in that it allows you to recode values in a column of a DataFrames with different values DataFrame based on a condition, but unlike `if_else()` which only lets you provide one condition, and two value options, `case_when()` allows you to have an unlimited number of conditions and corresponding recoded values. \n\nIn this section we will work with the `marital_status` column of the demographics data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> count(marital_status)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  marital_status          n\n  <chr>               <int>\n1 divorced              659\n2 living_with_partner   417\n3 married              2965\n4 never_married        1112\n5 separated             177\n6 widowed               436\n7 <NA>                 4409\n```\n\n\n:::\n:::\n\n\nTo create a new variable based on `marital_status` that replaces `\"married\"` with `3`, `\"living_with_partner\"` with `2`, and each of `\"divorced\"`, `\"widowed\"`, `\"never_married\"`, and `\"separated\"` with `1`, you can use the following code (the `select()` function at the end just allows us to view the original and the new columns side-by-side). \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> mutate(marital_status_numeric = case_when(marital_status == \"married\" ~ 3,\n                                                          marital_status == \"living_with_partner\" ~ 2,\n                                                          marital_status == \"divorced\" ~ 1,\n                                                          marital_status == \"widowed\" ~ 1,\n                                                          marital_status == \"never_married\" ~ 1,\n                                                          marital_status == \"separated\" ~ 1)) |>\n  select(marital_status, marital_status_numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,175 × 2\n   marital_status marital_status_numeric\n   <chr>                           <dbl>\n 1 separated                           1\n 2 married                             3\n 3 married                             3\n 4 <NA>                               NA\n 5 married                             3\n 6 divorced                            1\n 7 <NA>                               NA\n 8 widowed                             1\n 9 married                             3\n10 divorced                            1\n# ℹ 10,165 more rows\n```\n\n\n:::\n:::\n\n\nThe argument syntax of `case_when()` is `CONDITION ~ new_value`, where for entries in the original column for which `CONDITION` is `TRUE`, the value `new_value` is returned. So in `marital_status == \"married\" ~ 3`, the `CONDITION` is `marital_status == \"married\"`, and the `new_value` is `3`.\n\nNote that if you have multiple values that you want to recode as the same value, you can use the `%in%` vector syntax for asking whether a variable is contained `%in%` a vector of values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> \n  mutate(marital_status_numeric = case_when(\n    marital_status == \"married\" ~ 3,\n    marital_status == \"living_with_partner\" ~ 2,\n    # replace the final four conditions with a single %in% condition:\n    marital_status %in% c(\"divorced\", \"widowed\", \"never_married\", \"separated\") ~ 1)\n  ) |>\n  select(marital_status, marital_status_numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,175 × 2\n   marital_status marital_status_numeric\n   <chr>                           <dbl>\n 1 separated                           1\n 2 married                             3\n 3 married                             3\n 4 <NA>                               NA\n 5 married                             3\n 6 divorced                            1\n 7 <NA>                               NA\n 8 widowed                             1\n 9 married                             3\n10 divorced                            1\n# ℹ 10,165 more rows\n```\n\n\n:::\n:::\n\n\n\n## Execise\n\nUse `case_when()` to convert `born_usa` and `citizen_usa` to \"yes\" and \"no\". Bonus points: use `across()`. \n\n\nTo do this without `across()`, you can write:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> mutate(born_usa_chr = case_when(born_usa ~ \"yes\",\n                                                !born_usa ~ \"no\"),\n                       citizen_usa_chr = case_when(citizen_usa ~ \"yes\",\n                                                   !citizen_usa ~ \"no\")) |>\n  select(born_usa, born_usa_chr, citizen_usa, citizen_usa_chr) |> \n  sample_n(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n   born_usa born_usa_chr citizen_usa citizen_usa_chr\n   <lgl>    <chr>        <lgl>       <chr>          \n 1 TRUE     yes          TRUE        yes            \n 2 TRUE     yes          TRUE        yes            \n 3 TRUE     yes          TRUE        yes            \n 4 FALSE    no           TRUE        yes            \n 5 FALSE    no           FALSE       no             \n 6 TRUE     yes          TRUE        yes            \n 7 TRUE     yes          TRUE        yes            \n 8 TRUE     yes          TRUE        yes            \n 9 FALSE    no           FALSE       no             \n10 TRUE     yes          TRUE        yes            \n```\n\n\n:::\n:::\n\n\nNote that `born_usa ~ \"yes\"` is equivalent to `born_usa == TRUE ~ \"yes\"`, but the `== TRUE` is redundant because `born_usa` is itself a logical variable. Similarly, `!citizen_usa ~ \"no\"` is equivalent to `citizen_usa == FALSE ~ \"no\"`.\n\nTo use `across()`, the relevant select helper is something like `ends_with(\"_usa\")` or `contains(\"usa\")`, and you provide a `~` before `case_when()` to start an anonymous function, and you need to replace the column name with `.` (again, you don't need the `== TRUE` for this particular example in the condition, but that's just because the columns we're applying the `case_when()` function to are logical).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics |> mutate(across(ends_with(\"_usa\"), \n                              ~case_when(. == TRUE ~ \"yes\",\n                                         . == FALSE ~ \"no\"),\n                              .names = \"{.col}_chr\")) |>\n  select(contains(\"_usa\")) |> \n  sample_n(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n   born_usa citizen_usa born_usa_chr citizen_usa_chr\n   <lgl>    <lgl>       <chr>        <chr>          \n 1 TRUE     TRUE        yes          yes            \n 2 TRUE     TRUE        yes          yes            \n 3 TRUE     TRUE        yes          yes            \n 4 TRUE     TRUE        yes          yes            \n 5 TRUE     TRUE        yes          yes            \n 6 FALSE    TRUE        no           yes            \n 7 TRUE     TRUE        yes          yes            \n 8 TRUE     TRUE        yes          yes            \n 9 TRUE     TRUE        yes          yes            \n10 TRUE     TRUE        yes          yes            \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}