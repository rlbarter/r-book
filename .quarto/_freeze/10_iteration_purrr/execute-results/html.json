{
  "hash": "d3399a39c165e97e4a48a9451a971310",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iteration with purrr\"\nformat: html\neditor_options: \n  chunk_output_type: console\n---\n\n\nThe purpose of this lesson is to learn how to iteratively apply functions to all elements contained within an object, such as all columns in a data frame, or all entries in a vector.\n\n\nSince we will be continuing with the demographics NHANES data we were using previously, we will first need to load in that dataset. To do that, we will also need to load the tidyverse library.\n\nNote that the \"purrr\" R package that we will be using in this lesson is *included* in the tidyverse package, so that it it not necessary to also load the purrr package separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n#library(purrr)\ndemographics <- read_csv(\"data/demographics.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10175 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): interview_examination, gender, race, marital_status, pregnant\ndbl (9): respondent_id, age_years, age_months_sc_0_2yr, six_month_period, ag...\nlgl (5): served_active_duty_us, served_active_duty_foreign, born_usa, citize...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\nTo start with, the function that we want to iterate first is the `n_distinct()` function from the tidyverse. \n\nRecall that to pull up the help page for a function, you can use the following syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?n_distinct\n```\n:::\n\n\n`n_distinct()` counts the number of unique values in a vector. For example, if we want to apply `n_distinct()` to count the number of unique values in the `gender` column from the `demographics` data frame, we can first extract it as a vector using `demographics$gender` and then apply `n_distinct()` to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_distinct(demographics$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nWhat if we want to do this simultaneously to all columns. Rather than repeating our code above over and over again, we can instead use the `map()` function. \n\nThe `map()` function takes two arguments. The first is the object whose elements that we want to iterate over and the second is the function that we want to apply to each element in our object. \n\nWhen our object is a data frame, the elements being iterated over are the *columns* of the data frame.\n\nThe code below uses the `map()` function to apply `n_distinct()` to every column of the `demographics` data frame simultanesouly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(demographics, n_distinct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$respondent_id\n[1] 10175\n\n$interview_examination\n[1] 2\n\n$gender\n[1] 2\n\n$age_years\n[1] 81\n\n$age_months_sc_0_2yr\n[1] 26\n\n$race\n[1] 6\n\n$six_month_period\n[1] 3\n\n$age_months_ex_0_19yr\n[1] 241\n\n$served_active_duty_us\n[1] 3\n\n$served_active_duty_foreign\n[1] 3\n\n$born_usa\n[1] 3\n\n$citizen_usa\n[1] 3\n\n$time_in_us\n[1] 10\n\n$education_youth\n[1] 16\n\n$education\n[1] 6\n\n$marital_status\n[1] 7\n\n$pregnant\n[1] 4\n\n$language_english\n[1] 2\n\n$household_income\n[1] 13\n```\n\n\n:::\n:::\n\n\n\nThe output of the `map()` function is a list (more on that in a moment).\n\nThe following code shows another example, this time applying the `exp()` function to all entries/elements in a simple numeric vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(4, 5, 6), exp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 54.59815\n\n[[2]]\n[1] 148.4132\n\n[[3]]\n[1] 403.4288\n```\n\n\n:::\n:::\n\n\n\nAgain, the output of the `map()` function is a list.\n\n### Lists\n\n\nLet's talk about lists. Lists, like vectors, correspond to a collection of values contained in a single object. \n\nYou can use the `list()` function to define a list, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(1, 4, 7)\n```\n:::\n\n\nYou can extract elements from a list just as you would from a vector, using the square bracket notation. The code below extracts the third element from `my_list`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 7\n```\n\n\n:::\n:::\n\n\nHowever, note that the output above is also a list itself.\n\nIf you want to extract the actual object/value contained within the third element of the list, then you need to use double square parentheses:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\nNote that unlike vectors, lists are not vectorized. This means that you cannot conduct operations like adding 1 to a list. For a vector, this would add 1 to each element of the vector. But for a list, you just get an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_list + 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\nWhy would we ever prefer lists to vectors? The reason is that lists are infinitely more flexible than vectors. While all entries in a vector must be a *single value* of the *same type*, entries of a list can be anything. \n\nFor example, the code below creates a list that contains three entries: the head of the `demographics` data frame, the value 2, and a vector of the character values \"a\" and \"b\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_complex_list <- list(head(demographics), 2, c(\"a\", \"b\"))\nmy_complex_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tibble: 6 × 19\n  respondent_id interview_examination gender age_years age_months_sc_0_2yr race \n          <dbl> <chr>                 <chr>      <dbl>               <dbl> <chr>\n1         73557 both interview and e… male          69                  NA black\n2         73558 both interview and e… male          54                  NA white\n3         73559 both interview and e… male          72                  NA white\n4         73560 both interview and e… male           9                  NA white\n5         73561 both interview and e… female        73                  NA white\n6         73562 both interview and e… male          56                  NA mexi…\n# ℹ 13 more variables: six_month_period <dbl>, age_months_ex_0_19yr <dbl>,\n#   served_active_duty_us <lgl>, served_active_duty_foreign <lgl>,\n#   born_usa <lgl>, citizen_usa <lgl>, time_in_us <dbl>, education_youth <dbl>,\n#   education <dbl>, marital_status <chr>, pregnant <chr>,\n#   language_english <lgl>, household_income <dbl>\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] \"a\" \"b\"\n```\n\n\n:::\n:::\n\n\nYou can also create a *named* list when defining it as if you are defining argument names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_complex_list <- list(data = head(demographics), value = 2, vector = c(\"a\", \"b\"))\nmy_complex_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$data\n# A tibble: 6 × 19\n  respondent_id interview_examination gender age_years age_months_sc_0_2yr race \n          <dbl> <chr>                 <chr>      <dbl>               <dbl> <chr>\n1         73557 both interview and e… male          69                  NA black\n2         73558 both interview and e… male          54                  NA white\n3         73559 both interview and e… male          72                  NA white\n4         73560 both interview and e… male           9                  NA white\n5         73561 both interview and e… female        73                  NA white\n6         73562 both interview and e… male          56                  NA mexi…\n# ℹ 13 more variables: six_month_period <dbl>, age_months_ex_0_19yr <dbl>,\n#   served_active_duty_us <lgl>, served_active_duty_foreign <lgl>,\n#   born_usa <lgl>, citizen_usa <lgl>, time_in_us <dbl>, education_youth <dbl>,\n#   education <dbl>, marital_status <chr>, pregnant <chr>,\n#   language_english <lgl>, household_income <dbl>\n\n$value\n[1] 2\n\n$vector\n[1] \"a\" \"b\"\n```\n\n\n:::\n:::\n\n\n\n### Exercise\n\nUse `map()` and `class()` to identify the type/class of each column in the demographics dataset, and extract the class of the `household_income` column.\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics_class <- map(demographics, class)\n```\n:::\n\n\nThe `household_income` is the last column in the `demographics` data frame. There are several ways to extract it's class from the `demographics_class` list object.\n\nFirst is using numeric positional indexing inside square parentheses. Tip: You can use `ncol(demographics)` to extract the final column without having to actually know what integer position the final column corresponds to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics_class[ncol(demographics)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$household_income\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndemographics_class[19]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$household_income\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nYou can also use named indexing, by providing the list element name as a *character* inside one or two square parentheses (depending if you want the output to be a list of length 1 or just the value contained in the list element):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics_class[[\"household_income\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nAnd you can also use the `$` syntax with the list element name (without quotes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics_class$household_income\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nNote that these are the same techniques that you can use for extracting a column from a data frame. This is because a data frame is actually a special case of a list, where each element of the list is a vector corresponding to each column, and each of the vectors have the same length.\n\n\n\n\n\n## Using custom functions in purrr\n\n\nTo iterate using your own custom functions in a purrr `map()` function, you can define your function and provide it in the second argument of `map()`. For example, below, we define the `exp_plus_one()` function, and we then apply this function iteratively to each of the values in the vector `c(1, 4, 5)` using `map()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp_plus_one <- function(x) {\n  return(exp(x) + 1)\n}\n\nmap(c(1, 4, 5), exp_plus_one)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3.718282\n\n[[2]]\n[1] 55.59815\n\n[[3]]\n[1] 149.4132\n```\n\n\n:::\n:::\n\n\nHowever, for simple functions like this one (e.g., functions that only involve a single line of code which is also the return statement), there is a shortcut that we can use which involves defining the function \"on the fly\" in the function argument of the `map()` function itself. \n\nThe code below does the same thing as the code in the previous chunk, but it doesn't give the function a name. A temporary function defined inside an argument this way is called an *\"anonymous function\"*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(1, 4, 5), function(x) exp(x) + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3.718282\n\n[[2]]\n[1] 55.59815\n\n[[3]]\n[1] 149.4132\n```\n\n\n:::\n:::\n\n\nHowever, we can go one step further and forego the `function(x)` part entirely using what I call the \"tilde-dot\" shorthand syntax. Here, we use the tilde `~` symbol to \"start\" an anonymous function and we use a `.` to represent the argument of our anonymous function. The code below uses the tilde-dot shorthand syntax which is equivalent to the code in each of the chunks above, but is significantly more succinct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tilde-dot syntax\nmap(c(1, 4, 5), ~{exp(.) + 1})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3.718282\n\n[[2]]\n[1] 55.59815\n\n[[3]]\n[1] 149.4132\n```\n\n\n:::\n:::\n\n\nAs another example of this shorthand syntax, we can use it to count the number of missing values in each column of the demographics data (which is defined/loaded in the first code chunk of this document). \n\nTo decide what should go inside the `~{}`, I typically use a representative value to test out my code first. For example, below, I take a single column `demographics$pregnant`, and I write out the code that I want to apply to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(demographics$pregnant))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8866\n```\n\n\n:::\n:::\n\n\nThen I take this code and place it inside the body of `~{}` and replace the test column `demographics$pregnant` with a `.` to apply this code to *every* column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(demographics, ~{sum(is.na(.))})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$respondent_id\n[1] 0\n\n$interview_examination\n[1] 0\n\n$gender\n[1] 0\n\n$age_years\n[1] 0\n\n$age_months_sc_0_2yr\n[1] 9502\n\n$race\n[1] 0\n\n$six_month_period\n[1] 362\n\n$age_months_ex_0_19yr\n[1] 5962\n\n$served_active_duty_us\n[1] 3915\n\n$served_active_duty_foreign\n[1] 9633\n\n$born_usa\n[1] 5\n\n$citizen_usa\n[1] 11\n\n$time_in_us\n[1] 8353\n\n$education_youth\n[1] 7373\n\n$education\n[1] 4413\n\n$marital_status\n[1] 4409\n\n$pregnant\n[1] 8866\n\n$language_english\n[1] 0\n\n$household_income\n[1] 783\n```\n\n\n:::\n:::\n\n\n### Exercise \n\nUse the tilde-dot short-hand syntax to compute the number of values in each column that is equal to 1. Recall that if a vector has missing values, and you want to use `sum()`, you will want to provide an argument `na.rm = TRUE` to ignore missing values.\n\n#### Solution\n\nFirst, the code below does the long-form version which defines a function and then provides that function in the second argument of the `map()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_ones <- function(x) {\n  sum(x == 1, na.rm = TRUE)\n}\n\nmap(demographics, add_ones)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$respondent_id\n[1] 0\n\n$interview_examination\n[1] 0\n\n$gender\n[1] 0\n\n$age_years\n[1] 262\n\n$age_months_sc_0_2yr\n[1] 42\n\n$race\n[1] 0\n\n$six_month_period\n[1] 4823\n\n$age_months_ex_0_19yr\n[1] 30\n\n$served_active_duty_us\n[1] 543\n\n$served_active_duty_foreign\n[1] 282\n\n$born_usa\n[1] 8262\n\n$citizen_usa\n[1] 9220\n\n$time_in_us\n[1] 0\n\n$education_youth\n[1] 237\n\n$education\n[1] 455\n\n$marital_status\n[1] 0\n\n$pregnant\n[1] 0\n\n$language_english\n[1] 9100\n\n$household_income\n[1] 0\n```\n\n\n:::\n:::\n\n\nThen I make this more concise by taking the body of my `add_ones()` function above, and placing it inside `~{}`, and replace the `x` argument with a `.`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(demographics, ~{sum(. == 1, na.rm = TRUE)})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$respondent_id\n[1] 0\n\n$interview_examination\n[1] 0\n\n$gender\n[1] 0\n\n$age_years\n[1] 262\n\n$age_months_sc_0_2yr\n[1] 42\n\n$race\n[1] 0\n\n$six_month_period\n[1] 4823\n\n$age_months_ex_0_19yr\n[1] 30\n\n$served_active_duty_us\n[1] 543\n\n$served_active_duty_foreign\n[1] 282\n\n$born_usa\n[1] 8262\n\n$citizen_usa\n[1] 9220\n\n$time_in_us\n[1] 0\n\n$education_youth\n[1] 237\n\n$education\n[1] 455\n\n$marital_status\n[1] 0\n\n$pregnant\n[1] 0\n\n$language_english\n[1] 9100\n\n$household_income\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Alternative map functions for outputting doubles, characters and data frames\n\nLet's explore some alternative map functions that have different output types (i.e., they do not output a list). \n\nRecall our `map()` function previously that we used to count the number of missing values in each column of the demographics data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(demographics, ~sum(is.na(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$respondent_id\n[1] 0\n\n$interview_examination\n[1] 0\n\n$gender\n[1] 0\n\n$age_years\n[1] 0\n\n$age_months_sc_0_2yr\n[1] 9502\n\n$race\n[1] 0\n\n$six_month_period\n[1] 362\n\n$age_months_ex_0_19yr\n[1] 5962\n\n$served_active_duty_us\n[1] 3915\n\n$served_active_duty_foreign\n[1] 9633\n\n$born_usa\n[1] 5\n\n$citizen_usa\n[1] 11\n\n$time_in_us\n[1] 8353\n\n$education_youth\n[1] 7373\n\n$education\n[1] 4413\n\n$marital_status\n[1] 4409\n\n$pregnant\n[1] 8866\n\n$language_english\n[1] 0\n\n$household_income\n[1] 783\n```\n\n\n:::\n:::\n\n\nIt turns out that a list may not be the most useful format for this information. For instance, perhaps it would be more helpful to create a numeric vector instead. \n\n### Outputting numeric vectors\n\nThe `map_dbl()` function will output a \"double\" vector, where a double is a type of numeric value. Below, is the same code from above, but using `map_dbl()` outputs a *named* numeric/double vector, instead of a list (where the name of each element is inherited from the column names of the original data frame).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(demographics, ~sum(is.na(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             respondent_id      interview_examination \n                         0                          0 \n                    gender                  age_years \n                         0                          0 \n       age_months_sc_0_2yr                       race \n                      9502                          0 \n          six_month_period       age_months_ex_0_19yr \n                       362                       5962 \n     served_active_duty_us served_active_duty_foreign \n                      3915                       9633 \n                  born_usa                citizen_usa \n                         5                         11 \n                time_in_us            education_youth \n                      8353                       7373 \n                 education             marital_status \n                      4413                       4409 \n                  pregnant           language_english \n                      8866                          0 \n          household_income \n                       783 \n```\n\n\n:::\n:::\n\n\n\n### Outputting character vectors\n\nIf you are applying a function whose output is a character value (not a numeric value), such as `class()`, then you can use the `map_chr()` function to output a named *character* vector instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(demographics, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             respondent_id      interview_examination \n                 \"numeric\"                \"character\" \n                    gender                  age_years \n               \"character\"                  \"numeric\" \n       age_months_sc_0_2yr                       race \n                 \"numeric\"                \"character\" \n          six_month_period       age_months_ex_0_19yr \n                 \"numeric\"                  \"numeric\" \n     served_active_duty_us served_active_duty_foreign \n                 \"logical\"                  \"logical\" \n                  born_usa                citizen_usa \n                 \"logical\"                  \"logical\" \n                time_in_us            education_youth \n                 \"numeric\"                  \"numeric\" \n                 education             marital_status \n                 \"numeric\"                \"character\" \n                  pregnant           language_english \n               \"character\"                  \"logical\" \n          household_income \n                 \"numeric\" \n```\n\n\n:::\n:::\n\n\n\n### Outputting data frames\n\nOne of the most versatile functions is the `map_df()` function, which outputs a data frame. The code below outputs the class of each column in a \"wide\" single-row data frame, where each column in the original data frame has its own column in the output here. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(demographics, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 19\n  respondent_id interview_examination gender age_years age_months_sc_0_2yr race \n  <chr>         <chr>                 <chr>  <chr>     <chr>               <chr>\n1 numeric       character             chara… numeric   numeric             char…\n# ℹ 13 more variables: six_month_period <chr>, age_months_ex_0_19yr <chr>,\n#   served_active_duty_us <chr>, served_active_duty_foreign <chr>,\n#   born_usa <chr>, citizen_usa <chr>, time_in_us <chr>, education_youth <chr>,\n#   education <chr>, marital_status <chr>, pregnant <chr>,\n#   language_english <chr>, household_income <chr>\n```\n\n\n:::\n:::\n\n\nNote that if you want your output to be in a \"long\" format, where you have one column for the output of your function, you need to have the function you are applying output a single-column tibble/data frame, and these values will then be stacked vertically as you iterate. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(demographics, ~tibble(col_class = class(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 19 × 1\n   col_class\n   <chr>    \n 1 numeric  \n 2 character\n 3 character\n 4 numeric  \n 5 numeric  \n 6 character\n 7 numeric  \n 8 numeric  \n 9 logical  \n10 logical  \n11 logical  \n12 logical  \n13 numeric  \n14 numeric  \n15 numeric  \n16 character\n17 character\n18 logical  \n19 numeric  \n```\n\n\n:::\n:::\n\n\n\nYou can provide an `.id` argument to include the original column names as a variable in the output data frame too:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(demographics, ~tibble(col_class = class(.)), .id = \"variable_name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 19 × 2\n   variable_name              col_class\n   <chr>                      <chr>    \n 1 respondent_id              numeric  \n 2 interview_examination      character\n 3 gender                     character\n 4 age_years                  numeric  \n 5 age_months_sc_0_2yr        numeric  \n 6 race                       character\n 7 six_month_period           numeric  \n 8 age_months_ex_0_19yr       numeric  \n 9 served_active_duty_us      logical  \n10 served_active_duty_foreign logical  \n11 born_usa                   logical  \n12 citizen_usa                logical  \n13 time_in_us                 numeric  \n14 education_youth            numeric  \n15 education                  numeric  \n16 marital_status             character\n17 pregnant                   character\n18 language_english           logical  \n19 household_income           numeric  \n```\n\n\n:::\n:::\n\n\n### Example\n\nThis long-format is very useful if you want to create a plot, such as a bar chart for the number of missing values (recall that you will need to convert the `variable_name` column to a factor whose levels are in the order you want them to appear in your plot and you can add theme layers to customize the output of your plot).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(demographics, \n       ~tibble(n_missing = sum(is.na(.))), \n       .id = \"variable_name\") |>\n  arrange(n_missing) |>\n  mutate(variable_name = fct_inorder(variable_name)) |>\n  ggplot() +\n  geom_col(aes(x = variable_name, y = n_missing)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  theme_classic() +\n  theme(axis.text.x = element_text(angle = 90, \n                                   hjust = 1,\n                                   vjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](10_iteration_purrr_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "10_iteration_purrr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}