{"title":"Data Frames in the Tidyverse","markdown":{"yaml":{"title":"Data Frames in the Tidyverse","format":"html","embed-resources":true,"editor_options":{"chunk_output_type":"console"}},"headingText":"Installing and Loading R packages","containsRefs":false,"markdown":"\n\nI don't think it's an exaggeration to say that you probably wouldn't be learning the R programming language today were it not for the \"tidyverse\" and the human who led to its creation, Hadley Wickham. \n\nWhat is the \"tidyverse\"? R is an open source programming language, which means that anyone can enhance it by creating their own R functions. A collection of R functions can be bundled into a \"package\" or a \"library\" (I use these terms interchangeably).\n\nIn the 2010s, Hadley Wickham developed several transformative R packages, including \"dplyr\" and \"ggplot2\" (this chapter will introduce \"dplyr\" and you'll get to know \"ggplot2\" in the next chapter). These, along with other packages, form a suite collectively known as the \"tidyverse\"—so named because they help you create and work with \"tidy\" data.\n\nWhile Hadley Wickham created many of the foundational packages in the tidyverse, it has since grown to include contributions from hundreds of brilliant developers. Together, they have revolutionized the way we write R code for the better. The tidyverse and its impacts are a true testament to the power of the open source community.\n\n\n\n\n\nR packages are collections of \"add-on\" R functions that you can \"load\" into your R session to provide you with additional functionality. For example, the \"dplyr\" package provides functions that allow you to work with data frames.\n\nTo use functions from a package, you need to do two things:\n\n1. Install the package onto your computer. *You only need to do this once.*\n\n2. Load your package into your current R session. *You need to do this every time you start a new R session (i.e., every time you open up RStudio).*\n\nI like to think of installing a package like installing a new application (like RStudio!) onto your computer. You only ever need to install the application once (unless you're updating it), but you need to open it every time you want to use it (in this analogy, loading a library is like \"opening\" your application).\n\n\n### Installing an R package\n\nSo to get started with dplyr, ggplot2, and the other tidyverse packages, we need to *install* them. But to make our lives easier, you can now simultaneously install all of the tidyverse packages (ggplot2, dplyr, reshape, purrr, readr, and many others) by just installing the \"tidyverse\" package itself.\n\n\nTo install the \"tidyverse\" package (or any other package), you can write the following code *directly into your console* (I do *not* recommend saving this code in a quarto document or R script, because you only need to install a package once):\n\n```{r}\n#| eval: false\n# run in the console: \ninstall.packages(\"tidyverse\")\n```\n\nNote that you need to be connected to the internet to install a package (since it's like downloading an application from the internet.)\n\n### Loading an R package\n\nOnce you've installed it, every time you want to *use* an installed R package in a new R session, you need to *\"load\"* it using the library() function. \n\n```{r}\nlibrary(tidyverse)\n```\n\nSince you need to run this every time you open RStudio, you should include this code in the first chunk of your quarto document or R script.\n\nWhen you load libraries in R, you'll often see a lot of message \"output\" (what I like to call \"chatter\"). This output is completely normal and nothing to worry about. However, if you see the word \"Error\" in the message output, then you'll want to check whether you've properly installed the package you're trying to load. I usually do that by just running, for example, `install.packages(\"tidyverse\")` again and seeing what happens.\n\nIf you are loading a library in a quarto document and you want to hide the message output in the resulting rendered document, you can use the chunk option `#| message: false`, such as:\n\n```{{r}}\n#| message: false\nlibrary(dplyr)\n```\n\n\n\n\n\n## Tibbles and the `read_csv()` function\n\nIn the last chapter, we used a \"base R\" function (`read.csv()`) to load our gapminder dataset. \"base R\" refers to functions that are available in R and do not require you to load any additional libraries.\n\n\nWhile it's perfectly fine to continue to use this function, it is recommended that you switch to a slightly different function that has an underscore instead of a period in its name: `read_csv()`. This function is part of the tidyverse and is a little bit more efficient and user-friendly than `read.csv()`.\n\nLet's use `read_csv()` (the tidyverse version of `read.csv()`) to load the gapminder dataset:\n\n```{r}\ngapminder <- read_csv(\"data/gapminder.csv\")\n```\n\nIf you ran this in your own console and you got an error saying \"*Error in read_csv(\"data/gapminder.csv\") : could not find function \"read_csv\"*\", make sure you have installed the tidyverse and have run the code `library(tidyverse)` in your console! R can only find the `read_csv()` function if you have loaded the tidyverse!\n\nNow let's take a look at gapminder (*without using `head()`*)\n\n```{r}\ngapminder\n```\n\n\nDo you notice any differences between this version of `gapminder` that has been loaded using the tidyverse `read_csv()` and the version from the previous chapter that was loaded using the base R `read.csv()` function?\n\nTo make your life easier, here is the version of `gapminder` that we loaded with the base R `read.csv()` function:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder_base_r <- read.csv(\"data/gapminder.csv\")\ngapminder_base_r\n```\n\nHere are the main differences:\n\n1. The version loaded using  the base R `read.csv()` function prints out the first 1000 rows (though I've put them all in a cute a scrolly box for you), whereas the version loaded using the tidyverse `read_csv()` function only prints out the first 10 rows (and 10 columns).\n\n2. The version loaded using the tidyverse `read_csv()` function will also show you what *type*/*class* each columns has. Look underneath the column names of the tidyverse `read_csv()` version of `gapminder` above. See the `<chr>` and `<dbl>` symbols? These mean \"character\" and \"double\" (\"double\" means \"numeric with decimals\"), respectively.  \n\n3. The tidyverse `read_csv()` version prints out some information at the top that says `# A tibble: 1,704 × 6`, which tells us that our data frame has 1,704 rows and 6 columns. But what's the \"tibble\" part? It turns out that `read_csv()` doesn't actually load your data in as a data frame. It loads your data in as a *\"tibble\"*.\n\nA tibble is just a fancy data frame. In fact, for our purposes, a tibble *is* just a data frame. The only difference is that when it is printed to the console or as output in your quarto document, the tibble will only print the first 10 rows and the first 10 columns, as well as the extra pieces of information listed above.\nOverall, tibbles are just a bit more user friendly than the classic data frame, but it really doesn't matter whether you load in your data as a tibble using `read_csv()` or as a data frame using `read.csv()`. Especially because many of the functions that are going to be introduced in this chapter will output a tibble regardless of whether their input is a tibble or a data frame.\n    \nFrom here on, I will use the term data frame and tibble interchangeably to mean the same thing (I will usually use the term \"data frame\" even if the object is a tibble). If you don't understand the difference. Don't worry. Whenever you see \"tibble\", just replace it with \"data frame\" in your head, and you're good to go.\n\n\n## The dplyr library\n\nProbably the most important library in the tidyverse is the \"dplyr\" library. The \"dplyr\" library contains a bunch of functions that allow you to do things (like select columns, modify columns, filter based on conditions, etc) with data frames really easily.\n\nLike all \"tidyverse\" packages, to access the functions from the \"dplyr\" package, you just need to load the tidyverse library using `library(tidyverse)`.\n\nThe main dplyr functions you need to master are:\n\n- `select()`: extract columns from your data frame\n\n- `filter()`: filter to rows of your data frame based on a condition\n\n- `mutate()`: add columns or modify columns in your data frame\n\n- `summarize()`: aggregate information in your columns\n\n- `group_by()`: perform an operation separately for each entry in a categorical column\n\nOnce you feel comfortable with these five functions, you're officially a competent tidyverse R user. We're going to introduce all of them in this chapter, one by one. Then we're going to do fancy things like *combining* them together with something called the \"*pipe*\" (which looks like this: `|>` or like this `%>%` if you've been around the R scene for a while) \n\nReady? Let's go!\n\n\n\n\n## Select() for extacting columns\n\nWe can use the `select()` function to extract specific named columns from our data frame. \n\nThe *first argument* of `select()` is always the data frame on which you are operating, and all of the *remaining arguments* are the names of the columns that you want to keep. Note that the column names do *not* have quotes around them. This is something that makes dplyr (and tidyverse) functions special (and involves something called \"tidy evaluation\" that we won't talk about any time soon).\n\nSo if we want to extract just the country, year, and life expectancy columns from our gapminder data frame, we can write:\n\n```{r}\nselect(gapminder, country, year, lifeExp)\n```\n\n\nWe can also remove columns by using a minus sign in front of the column name. For example, the following code will return the gapminder data frame *without* the continent, year, and pop columns:\n\n```{r}\nselect(gapminder, -continent, -year, -pop)\n```\n\n\nSelect can also help you rename columns. If you just provide the column name as an argument, the column name will remain unchanged. However, if you provide the column name as `new_name = old_name`, the column will be renamed to whatever you provide as `new_name`. For example, the following code will return the gapminder data frame with the country, year, lifeExp, and gdpPercap columns, except the lifeExp column will be renamed to life_exp and the gdpPercap column renamed to gdp_per_cap:\n\n```{r}\nselect(gapminder, country, year, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\nHowever, since select will only return the columns that are included in its arguments, if you want to rename a column without removing any columns, you might want to use the `rename()` function instead. \n\nFor example, the following code will return *all columns* in the gapminder data frame, with the lifeExp column renamed to life_exp and the gdpPercap column renamed to gdp_per_cap:\n\n\n```{r}\nrename(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\n:::: {.panel-tabset}\n\n## Question\n\nWhat would happen if I replaced `rename()` in the code above with `select()`? \n\n## Answer \n\n```{r}\nselect(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\n\n::::\n\n\n\n\n\n\n\n## The pipe `|>` (formerly `%>%`)\n\nRemember how I was being all gushy about the tidyverse? Honestly, the main reason for that is the **pipe**. The pipe makes is so we can read our code as if it is a sentence. For example, if I wanted to turn the following sentence \"*I take my backpack and then I put books in it and then put it on my back*\" using the pipe, I would write `backpack |> put_books_in() |> put_on_back()`. I always think of the pipe operator `|>` as the word \"and then\" in a sentence. \n\nSo for the following code, I can read it as \"*take the gapminder data frame and then select the country, year, and lifeExp columns*\":\n\n```{r}\ngapminder |> select(country, year, lifeExp)\n```\n\n\nThe pipe syntax is: `object |> function()`. The way it works is that the object to the left of the pipe (`|>`) is placed into the *first argument* of the function to the right of the pipe (`|>`).\n\nThis means that the following two pieces of code are equivalent:\n\n```{r}\n# apply head() to gapminder directly\nhead(gapminder)\n# apply head() to gapminder using the pipe\ngapminder |> head()\n```\n\nThe second version with the pipe takes the `gapminder` data frame (which is to the left of the pipe) and places it into the (first) argument of the `head()` function on the right of the pipe. The pipe always has an object (like a data frame) on its left and a function on its right.\n\nHere is another example of two pieces of equivalent code, first one with the pipe:\n\n```{r}\n# apply select to gapminder, year, and pop without the pipe\nselect(gapminder, year, pop)\n```\n\nAnd the version with the pipe:\n\n```{r}\n# apply select to gapminder, year, and pop with the pipe\ngapminder |> select(year, pop)\n```\n\nRemember that the pipe places the object on the left of the pipe into the first argument of the function on the right of the pipe. So if the function takes more than one argument (as `select()` does), then you place the remaining arguments inside the parentheses of the function on the right of the pipe.\n\n\n:::{.callout-tip}\n## The \"new\" pipe `|>` versus the \"old\" pipe `%>%`\n\nThe pipe `|>` is now a part of the R programming language. Previously, you needed to load the magrittr, dplyr, or tidyverse libraries to access the pipe and it had a different symbol: `%>%` (there are very minor differences in functionality). This still works, but it is now recommended that you use the newer \"native\" pipe syntax: `|>`. \n:::\n\n\n\n\n## Filtering rows using filter()\n\n\nThe filter function lets you filter to specific rows based on a condition.\n\nImagine that we just want to look at the rows in the data corresponding to Australia. Recall that you can apply *logical operations* to a vector (in this case the \"country\" column of `gapminder`) as follows:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder$country == \"Australia\"\n```\n\nIf we just take the part of this statement that follows the `$` (i.e., `country == \"Australia\"`) and place it in the second argument of the `filter()` function, we can filter to just the rows in the data frame where the country is Australia (Note: no `$` extraction required!):\n\n```{r}\nfilter(gapminder, country == \"Australia\")\n```\n\nJust like `select()`, the first argument of `filter()` is always the data frame on which you are operating. The second argument of `filter()` is the condition that you want to use filter. Only the rows for which the condition is `TRUE` will be returned. However, you can refer to the column names without quotes inside dplyr functions, even though there is no `country` variable in our environment. \n\n### Multiple filtering conditions\n\nYou can provide multiple conditions using a comma, i.e., by providing multiple conditions as arguments to `filter()`. For example, the following code will filter the `gapminder` data frame to just the rows where both `country == \"Australia\"` AND `year > 1990` are `TRUE`. \n\n```{r}\nfilter(gapminder, country == \"Australia\", year > 1990)\n```\n\nAnd now that we have met our trusty pipe, we can rewrite this code as:\n\n```{r}\ngapminder |> filter(country == \"Australia\", year > 1990)\n```\n\nRemember that you can read this as \"take the gapminder data frame *and then* filter to the rows where the country is Australia and the year is greater than 1970\".\n\nWhile the pipe might not seem to be bringing much to the party just yet, rest assured the pipe is a game changer. To start to get a sense of why, let's use it to combine some sequential `filter()` and `select()` operations. \n\nFirst: filter to the continent of Africa, where the year is equal to 1992\n\nThen: return just the country and lifeExp columns (rename lifeExp to be life_exp)\n\n```{r}\ngapminder |> \n  filter(continent == \"Africa\", year == 1992) |> \n  select(country, life_exp = lifeExp)\n```\n\nNote that I like to start a new line *after* each pipe `|>` to make the code more readable. \n\nHow would you read this code as a sentence? I would read it as \"take the gapminder dataset *and then* filter to just the rows where the continent column is equal to \"Africa\" and the year is equal to 1992 *and then* select just the country and life expectancy columns, renaming life expectancy to be life_exp\".\n\nIf I wanted to try to write this code without the pipe, I would have to do it in a few steps like this:\n\n```{r}\ngapminder_africa_1992 <- filter(gapminder, continent == \"Africa\", year == 1992)\nselect(gapminder_africa_1992, country, life_exp = lifeExp)\n```\n\nWithout the pipe, I am forced to define an intermediate object, `gapminder_africa_1992` (or do some kind of disgusting nested function stuff), which feels inefficient now that we have the pipe. The pipe allows me to do everything in a single more readable and efficient operation.\n\n### The order of operations\n\nIt turns out that the order of operations can be fairly important.\n\nFor example, if I swap the order of the `select()` operation and the `filter()` operation in the code above, I will get an error:\n\n```{r}\n#| error: true\n\n# swap the filter and select steps above\ngapminder |> \n  select(country, life_exp = lifeExp) |>\n  filter(continent == \"Africa\", year == 1992) \n```\n\nWhy do you think this happens? Take a look at the error message for a hint. The issue is not that the `gapminder` object itself doesn't contain a \"continent\" column... what data frame is being piped into the `filter()` function? You can run just the first two lines of code to see:\n\n\n```{r}\ngapminder |> \n  select(country, life_exp = lifeExp) \n```\n\nThis is the data frame that is being piped into `filter()`. Does it contain a \"continent\" column? No it does not! So the `filter()` function is trying to filter to rows for which the \"continent\" column is equal to \"Africa\" in a data frame that doesn't contain a \"continent\" column. The following two pieces of code are therefore *not* equivalent:\n\n```{r}\n#| eval: false\ngapminder |> \n  filter(continent == \"Africa\", year == 1992) |>\n  select(country, life_exp = lifeExp) \n  \n```\n\n\n```{r}\n#| eval: false\ngapminder |> \n  select(country, life_exp = lifeExp) |>\n  filter(continent == \"Africa\", year == 1992) \n```\n\n\n### Filtering using \"OR\" conditions\n\nHow would you go about filtering to the rows where country corresponds to Australia and Italy. You might imagine that you can just provide these two conditions separated by a comma, as in:\n\n```{r}\ngapminder |> filter(country == \"Australia\", country == \"Italy\")\n```\n\nHowever, this has returned an *empty* data frame with 0 rows. Why has this happened?\n\nRemember that whenever you provide two conditions to `filter()` with a comma, R filters to the rows where *both* conditions are true. That is, a comma corresponds to an \"AND\" condition: `filter(country == \"Australia\", country == \"Italy\")` means \"filter to the rows where `country == \"Australia\"` AND `country == \"Italy\"` are both true. However, there are no rows where `country` is simultaneously equal to \"Australia\" and \"Italy\". It is only ever equal to one or the other. \n\nAlthough I phrased my desire as \"filter to the rows where country country corresponds to Australia **and** Italy\", I really meant, \"filter to the rows country corresponds to Australia **or** Italy\".\n\nCan you remember how to ask an \"OR\" question? You use the vertical bar `|`. So to ask this question, I could provide two conditions separated by a vertical bar `(condition 1) | (condition 2)`, which will return all rows where *either* condition 1 *or* condition 2 are satisfied.\n\n\n```{r}\ngapminder |> filter((country == \"Australia\") | (country == \"Italy\"))\n```\n\n\nOr if both conditions involve the same variable (in this case, `country`), you can use the `%in%` operator! Remember that you can ask which values in a vector are also in some other vector, such as asking which values in the vector `c(1, 5, 2, 2, 1, 6)` are equal to `1` or `2` (i.e., are in the vector `c(1, 2)`) by writing:\n\n```{r}\nc(1, 5, 2, 2, 1, 6) %in% c(1, 2)\n```\n\n\nWe can use this same `%in% `operator to ask which entries of `country` column are equal to `\"Australia\"` or `\"Italy\"`:\n\n```{r}\ngapminder |> filter(country %in% c(\"Australia\", \"Italy\"))\n```\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nFilter gapminder to all countries on the Oceania continent for just the years 1987 and 1992 and select just the country, year, and gdpPercap columns (where you have renamed `gdpPercap` to be `gdp_per_cap`). \n\nSave the output in an object called gapminder_oceania, and print `gapminder_oceania` to the console.\n\n## Solution\n\n```{r}\ngapminder_oceania <- gapminder |> \n  filter(continent == \"Oceania\", year %in% c(1987, 1992)) |>\n  select(country, year, gdp_per_cap = gdpPercap)\ngapminder_oceania\n```\n\n\n::::\n\n\n\n\n\n\n\n\n\n\n\n## Adding and modifying columns using mutate()\n\nLet's move from filtering our rows using `filter()` onto adding and modifying our columns using `mutate()`!\n\nIf I wanted to add a new column to my data, called `gdp`, which is the product of the `pop` and `gdpPercap` columns, I can do that using `mutate()`. \n\n```{r}\ngapminder |> mutate(gdp = pop * gdpPercap) \n```\n\nRemember that the code above hasn't actually modified gapminder. To modify gapminder I would need to *reassign* gapminder to the mutated dataframe: `gaminder <- gapminder |> mutate(gdp = pop * gdpPercap)`.\n\nWhat this code has done is it has created a brand new column, `gdp`, and plopped it at the end of my data frame (and it's printed out the resulting data frame without saving it as a new variable). In this case, each value in the `gdp` column contains product of the corresponding values in the `pop` and `gdpPercap` columns.\n\nThe general syntax for mutate is `df |> mutate(new column name = some operation involving existing columns)`, and because `mutate()` is a tidyverse function, we can refer to the columns of our data frame without needing quotes. \n\n\nAs another example, if we wanted to create a new column that contained the population in millions, i.e., divided by 1 million, we could do that using\n\n```{r}\ngapminder |> mutate(pop_mil = pop / 1e6)\n```\n\n\nNote that `1e6` is scientific notation for `1000000` (i.e., `1` followed by 6 `0`s).\n\nWhile `mutate()` is often used to create *new* columns, it can also be used to *modify existing* columns. For example, the code below will modify the existing `lifeExp` column by rounding it to the nearest integer. \n\n```{r}\ngapminder |> mutate(lifeExp = round(lifeExp)) \n```\n\nNote that no new columns have been added to the end of our `gapminder` output. The data frame contains the exact same columns as the original `gapminder` object, except the `lifeExp` column is now an integer!\n\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nModify `gapminder_tmp` using mutate() so that it contains a log(pop) column (in addition to the original `pop` column), and round the gdpPercap column to the nearest integer. The first 6 rows of your output should look like this:\n\n```{r}\n#| echo: false\n\ngapminder |> mutate(log_pop = log(pop), gdpPercap = round(gdpPercap)) |> head()\n```\n\n\n\n## Solution\n\n```{r}\ngapminder |> \n  mutate(log_pop = log(pop), gdpPercap = round(gdpPercap)) |> \n  head()\n```\n\n::::\n\n\n\n\n\n\n\n\n\n## Summarizing data frames using summarize()\n\nThe functions that we have discussed do far in this chapter (`select()`, `filter()` and `mutate()`) are all functions that can be used to create a *modified* version of your data frame.\n\nIn this section, we will introduce `summarize()`, which can be used to--you guessed it--*summarize* your data frame.\n\nAs an example, let's use summarize to compute the average `lifeExp` value across all rows in the dataset. If `lifeExp` was a vector object in our space, we would compute the average value by writing `mean(lifeExp)`. But since `lifeExp` is not a variable in our space, it is a column in our data, we can compute the average `lifeExp` value by providing this `mean(lifeExp)` operation inside the `summarize()` function as follows:\n\n```{r}\ngapminder |> summarize(mean(lifeExp))\n```\n\n\nYou can read this as: \"take the gapminder dataset *and then* summarize it by computing `mean(lifeExp)`, i.e., the mean of the `lifeExp` column\".\n\n\nHowever, like all of the other functions we have used in this chapter, the output of `summarize()` function is itself a data frame (albeit with just a single row and column). But notice that the name of the column in our summary data frame is just the function that was computed, `mean(lifeExp)`. Wouldn't it be nice if we could give this column a nicer name? Yes it would. Fortunately, this is super easy to do, by just providing a name for our summary operation inside the summary() function:\n\n```{r}\ngapminder |> summarize(mean_life_exp = mean(lifeExp))\n```\n\nIn this version, our one-row-one-column data frame has the column name `mean_life_exp`, instead of `mean(lifeExp)`. In general, I don't like having characters like `()` in the column names of my data frames, but this only really matters if I plan to use my data frame for something where I need to reference the column names (it matters less if I just want to look at it)!\n\n\nIt's also super easy to compute multiple summaries at once using our trusty comma:\n\n```{r}\ngapminder |> \n  summarize(mean_life_exp = mean(lifeExp), \n            max_population = max(pop))\n```\n\n\nYou don't need to put each summary computation on a new line, but it makes it a bit easier to read (e.g., compared with ` summarize(mean_life_exp = mean(lifeExp), max_population = max(pop))`).\n\n## Grouped operations with group_by()\n\nComputing a `summary()` operation across all of the rows at once is nice and all, but I'll forgive you if you're sitting there thinking \"Ok Rebecca, I know you love the tidyverse, and you want to pipe everything into everything else, but honestly it's just easier to use base R notation to do this, like:\"\n\n```{r}\nmean(gapminder$lifeExp)\n```\n\nAnd my response to you would be: yeah. It is. But just wait. The next thing I'm going to show you will blow your mind and force you to eat your words. \n\nWhat if... I asked you to compute the average life expectancy again, but to do it separately *for each continent*. \n\nWhile you could preceed your `summarize()` operation with a `filter()` operation for each continent like this:\n\n```{r}\ngapminder |> filter(continent == \"Asia\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Americas\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Africa\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Europe\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Oceania\") |> summarize(mean(lifeExp))\n```\n\n\nOr even use a for loop (if you so desired...), it turns out that there is a better way!\n\nThe true value of the `summarize()` function lies in its friendship with the `group_by()` function. The following code concisely computes the average `lifeExp` separately for each `continent` by \"grouping\" the gapminder data frame by continent (using `group_by()`) *before* summarizing.\n\n```{r}\ngapminder |> \n  group_by(continent) |> \n  summarize(mean_life_exp = mean(lifeExp))\n```\n\n\nYou can think about this as if `group_by()` is creating a separate data frame for each continent and then it is computing the `summarize()` operation *separately* for each continent data frame, and it is then combining the summary output into a two-column data frame, where the first column contains the respective `continent` value, and the second column contains the result of the `summary()` operation for that particular `continent`.\n\nNow that's rad as heck!\n\n\n:::: {.panel-tabset}\n## Exercise\n\nUse group_by() and summarize() to compute the standard deviation of the `gdpPercap` column separately for each country.\n\n## Solution\n\n```{r}\ngapminder |> \n  group_by(country) |> \n  summarize(max_pop = max(pop))\n```\n::::\n\n\n\n\n\n\n\n### Group_by multiple columns simultaneously\n\nJust in case you weren't already impressed enough by the group_by/summarize duo, you can also do more sophisticated grouping operations, such as computing the average `lifeExp` for each continent-year * combination* by gropuing by both `continent` and `year`:\n\n```{r}\n# compute the average life expectancy for each continent-year combination\ngapminder |> \n  group_by(continent, year) |> \n  summarize(mean_life_exp = mean(lifeExp))\n```\n\n\nWith `filter()`, `mutate()`, `group_by()`, and `summarize()` up your sleeve, there is almost no summarization of your data you can't do!\n\n\n:::: {.panel-tabset}\n## Exercise\n\nCompute the mean and standard deviation of the GDP (the product of `pop` and `gdpPercap`) separately for each year and continent after the year 2000. Your output should look like this:\n\n```{r}\n#| echo: false\ngapminder |>\n  filter(year > 2000) |>\n  mutate(gdp = pop * gdpPercap) |>\n  group_by(year, continent) |>\n  summarize(mean(gdp))\n```\n\n## Hint\n\nOne suggested order of operations is \n\n```{{r}}\ngapminder |>\n  filter() |>\n  mutate() |>\n  group_by() |>\n  summarize()\n```\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(year > 2000) |>\n  mutate(gdp = pop * gdpPercap) |>\n  group_by(year, continent) |>\n  summarize(mean(gdp))\n```\n::::\n\n\nWhile `group_by()` is most often used with `summarize()`, this doesn't mean that it can *only* be used with `summarize()`!\n\n#### Grouped mutates\n\nBelow, I group by `continent` and then I conduct a `mutate()` to add a new column `max_life_exp`, containing the maximum life expectancy for the corresponding country:\n\n```{r}\ngapminder_new <- gapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) \nprint(gapminder_new, n = 30)\n```\n\nTake a close look at the new `max_life_exp` column that I've tacked onto the end of my data frame. It contains the same value within each country! This time, I have created a new data frame object called `gapminder_new` because I want to continue working with this data frame object.\n\n\n### Don't forget to `ungroup()`\n\nSo we've got our `gapminder_new` object that contains our `max_life_exp` column which contains the maximum life expectancy value where the average is computed just using the corresponding country's rows.\n\nIf I then wanted to conduct a subsequent summarize operation on this `gapminder_new` object, such as computing the average `max_life_exp` value, with the goal of computing this average *over all rows in the data* (i.e., I should get a single value), I might write the following code:\n\n```{r}\ngapminder_new |> summarize(mean(max_life_exp))\n```\n\n\nIs there anything surprising about the output here? The `summary()` operation is still *grouped by country*, despite the fact that I didn't conduct another `group_by(country)` operation before my `summarize()` operation!\n\nThis is because `gapminder_new` is not technically a simple data frame... it is a *grouped* data frame. \n\n\n```{r}\ngapminder_new\n```\n\n\nIn defining `gapminder_new`, I used a `group_by()` operation, and you can see that when I print out `gapminder_new`, at the very top (well, technically, just under the very top) you will see some text that says: `# Groups:   country [142]`. This tells me that `gapminder_new` is *grouped* by the country column (and there are 142 groups). This means that any operations that I conduct on `gapminder_new` will also be grouped (by `country`). \n\n\nIf you are going to continue working with a data frame that was created using a `group_by()` operation, it is important to remember to `ungroup()`, unless you want your subsequent operations to also be grouped. This is what I really wanted to do: \n\n```{r}\ngapminder_new |> ungroup() |> summarize(mean(max_life_exp))\n```\n\nI could write all of this code without defining my intermediate `gapminder_new` object as follows:\n\n```{r}\ngapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) |>\n  ungroup() |>\n  summarize(mean(max_life_exp))\n```\n\nBut if I forgot the `ungroup()` operation (the second-last line above), I get:\n\n```{r}\ngapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) |>\n  summarize(mean(max_life_exp))\n```\n\n\n### Grouped filtering\n\nYou can also conduct grouped filtering, which will apply your filter condition separately for each group. The most common scenario in which I find myself doing this is when I want to do something like filter to the row in each group with the maximum value in one of the columns, such as filtering to the rows with the highest `lifeExp` separately *within each continent*:\n\n```{r}\ngapminder |>\n  group_by(continent) |>\n  filter(lifeExp == max(lifeExp))\n```\n\n\n## Count\n\nThe second-last function I want to show you in this chapter is the `count()` function. `count()` is just a really handy function for summarizing categorical (character/factor) variables. `count()` creates a two-column data frame, where the first column contains the unique values in the variable provided to `count()`, in this case `continent`, and the second column, `n`, contains the number of times that each `continent` value appears:\n\n```{r}\ngapminder |>\n  count(continent)\n```\n\n\n\n\n\n\n\n## Arrange\n\nThe final function I have for you is `arrange()`, which lets you arrange the rows of your data frame in ascending or descending order of the values in a specific column. By default, `arrange()` will arrange the rows in ascending order. The following will rearrange all of the rows so that the row with the smallest `lifeExp` value will be at the top and the row with the largest `lifeExp` value will be at the bottom:\n\n```{r}\ngapminder |>\n  arrange(lifeExp)\n```\n\n\nFor some reason, the way that you specify that the rows should be arranged in *descending* order instead is to wrap the variable name in the `desc()` function. Now the row with the largest `lifeExp` value will be at the top and the row with the smallest `lifeExp` value will be at the bottom:\n\n```{r}\ngapminder |>\n  arrange(desc(lifeExp))\n```\n\nTechnically, you could also just arrange by the negative of the column to arrange in descending order, but I usually use the `desc()` approach myself. \n\n```{r}\ngapminder |>\n  arrange(-lifeExp)\n```\n\n\n\n\n\n\n\n\n\nTo finish up and make sure you were paying attention, here are a bunch of fun exercises for you to complete:\n\n:::: {.panel-tabset}\n\n## Exercise\n\nCompute the *median* lifeExp and maximum `pop` value for each country, and then arrange the countries in descending order of their maximum `pop` value.\n\n## Solution\n\n```{r}\ngapminder |>\n  group_by(country) |>\n  summarize(median_life_exp = median(lifeExp),\n            max_pop = max(pop)) |>\n  arrange(desc(max_pop))\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\n\nIdentify the 5 countries with the highest *average* life expectancy.\n\n## Solution\n\n```{r}\ngapminder |>\n  group_by(country) |>\n  summarize(mean_life_exp = mean(lifeExp)) |>\n  ungroup() |>\n  arrange(desc(mean_life_exp)) |> \n  head(5)\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\nWhat are the three most populous countries on the \"Asia\" continent?\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(continent == \"Asia\") |>\n  group_by(country) |>\n  summarize(max_pop = max(pop)) |>\n  ungroup() |>\n  arrange(desc(max_pop)) |>\n  head(3)\n```\n::::\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nIdentify the country with the highest total GDP for each continent.\n\n## Hint\n\nApply a filter after a group_by -- this will apply the filtering separately for each group.\n\n## Solution\n\nThese are the countries with the highest total GDP for each continent:\n\n```{r}\ngapminder |>\n  mutate(gdp = gdpPercap * pop) |>\n  group_by(continent) |>\n  filter(gdp == max(gdp)) |>\n  select(country, continent, gdp)\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\nCompute the average GDP per capita for each continent based only on countries with `gdpPercap` greater than 20,000.\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(gdpPercap > 20000) |>\n  group_by(continent) |>\n  summarize(mean(gdpPercap))\n```\n\n::::","srcMarkdownNoYaml":"\n\nI don't think it's an exaggeration to say that you probably wouldn't be learning the R programming language today were it not for the \"tidyverse\" and the human who led to its creation, Hadley Wickham. \n\nWhat is the \"tidyverse\"? R is an open source programming language, which means that anyone can enhance it by creating their own R functions. A collection of R functions can be bundled into a \"package\" or a \"library\" (I use these terms interchangeably).\n\nIn the 2010s, Hadley Wickham developed several transformative R packages, including \"dplyr\" and \"ggplot2\" (this chapter will introduce \"dplyr\" and you'll get to know \"ggplot2\" in the next chapter). These, along with other packages, form a suite collectively known as the \"tidyverse\"—so named because they help you create and work with \"tidy\" data.\n\nWhile Hadley Wickham created many of the foundational packages in the tidyverse, it has since grown to include contributions from hundreds of brilliant developers. Together, they have revolutionized the way we write R code for the better. The tidyverse and its impacts are a true testament to the power of the open source community.\n\n\n\n## Installing and Loading R packages\n\n\nR packages are collections of \"add-on\" R functions that you can \"load\" into your R session to provide you with additional functionality. For example, the \"dplyr\" package provides functions that allow you to work with data frames.\n\nTo use functions from a package, you need to do two things:\n\n1. Install the package onto your computer. *You only need to do this once.*\n\n2. Load your package into your current R session. *You need to do this every time you start a new R session (i.e., every time you open up RStudio).*\n\nI like to think of installing a package like installing a new application (like RStudio!) onto your computer. You only ever need to install the application once (unless you're updating it), but you need to open it every time you want to use it (in this analogy, loading a library is like \"opening\" your application).\n\n\n### Installing an R package\n\nSo to get started with dplyr, ggplot2, and the other tidyverse packages, we need to *install* them. But to make our lives easier, you can now simultaneously install all of the tidyverse packages (ggplot2, dplyr, reshape, purrr, readr, and many others) by just installing the \"tidyverse\" package itself.\n\n\nTo install the \"tidyverse\" package (or any other package), you can write the following code *directly into your console* (I do *not* recommend saving this code in a quarto document or R script, because you only need to install a package once):\n\n```{r}\n#| eval: false\n# run in the console: \ninstall.packages(\"tidyverse\")\n```\n\nNote that you need to be connected to the internet to install a package (since it's like downloading an application from the internet.)\n\n### Loading an R package\n\nOnce you've installed it, every time you want to *use* an installed R package in a new R session, you need to *\"load\"* it using the library() function. \n\n```{r}\nlibrary(tidyverse)\n```\n\nSince you need to run this every time you open RStudio, you should include this code in the first chunk of your quarto document or R script.\n\nWhen you load libraries in R, you'll often see a lot of message \"output\" (what I like to call \"chatter\"). This output is completely normal and nothing to worry about. However, if you see the word \"Error\" in the message output, then you'll want to check whether you've properly installed the package you're trying to load. I usually do that by just running, for example, `install.packages(\"tidyverse\")` again and seeing what happens.\n\nIf you are loading a library in a quarto document and you want to hide the message output in the resulting rendered document, you can use the chunk option `#| message: false`, such as:\n\n```{{r}}\n#| message: false\nlibrary(dplyr)\n```\n\n\n\n\n\n## Tibbles and the `read_csv()` function\n\nIn the last chapter, we used a \"base R\" function (`read.csv()`) to load our gapminder dataset. \"base R\" refers to functions that are available in R and do not require you to load any additional libraries.\n\n\nWhile it's perfectly fine to continue to use this function, it is recommended that you switch to a slightly different function that has an underscore instead of a period in its name: `read_csv()`. This function is part of the tidyverse and is a little bit more efficient and user-friendly than `read.csv()`.\n\nLet's use `read_csv()` (the tidyverse version of `read.csv()`) to load the gapminder dataset:\n\n```{r}\ngapminder <- read_csv(\"data/gapminder.csv\")\n```\n\nIf you ran this in your own console and you got an error saying \"*Error in read_csv(\"data/gapminder.csv\") : could not find function \"read_csv\"*\", make sure you have installed the tidyverse and have run the code `library(tidyverse)` in your console! R can only find the `read_csv()` function if you have loaded the tidyverse!\n\nNow let's take a look at gapminder (*without using `head()`*)\n\n```{r}\ngapminder\n```\n\n\nDo you notice any differences between this version of `gapminder` that has been loaded using the tidyverse `read_csv()` and the version from the previous chapter that was loaded using the base R `read.csv()` function?\n\nTo make your life easier, here is the version of `gapminder` that we loaded with the base R `read.csv()` function:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder_base_r <- read.csv(\"data/gapminder.csv\")\ngapminder_base_r\n```\n\nHere are the main differences:\n\n1. The version loaded using  the base R `read.csv()` function prints out the first 1000 rows (though I've put them all in a cute a scrolly box for you), whereas the version loaded using the tidyverse `read_csv()` function only prints out the first 10 rows (and 10 columns).\n\n2. The version loaded using the tidyverse `read_csv()` function will also show you what *type*/*class* each columns has. Look underneath the column names of the tidyverse `read_csv()` version of `gapminder` above. See the `<chr>` and `<dbl>` symbols? These mean \"character\" and \"double\" (\"double\" means \"numeric with decimals\"), respectively.  \n\n3. The tidyverse `read_csv()` version prints out some information at the top that says `# A tibble: 1,704 × 6`, which tells us that our data frame has 1,704 rows and 6 columns. But what's the \"tibble\" part? It turns out that `read_csv()` doesn't actually load your data in as a data frame. It loads your data in as a *\"tibble\"*.\n\nA tibble is just a fancy data frame. In fact, for our purposes, a tibble *is* just a data frame. The only difference is that when it is printed to the console or as output in your quarto document, the tibble will only print the first 10 rows and the first 10 columns, as well as the extra pieces of information listed above.\nOverall, tibbles are just a bit more user friendly than the classic data frame, but it really doesn't matter whether you load in your data as a tibble using `read_csv()` or as a data frame using `read.csv()`. Especially because many of the functions that are going to be introduced in this chapter will output a tibble regardless of whether their input is a tibble or a data frame.\n    \nFrom here on, I will use the term data frame and tibble interchangeably to mean the same thing (I will usually use the term \"data frame\" even if the object is a tibble). If you don't understand the difference. Don't worry. Whenever you see \"tibble\", just replace it with \"data frame\" in your head, and you're good to go.\n\n\n## The dplyr library\n\nProbably the most important library in the tidyverse is the \"dplyr\" library. The \"dplyr\" library contains a bunch of functions that allow you to do things (like select columns, modify columns, filter based on conditions, etc) with data frames really easily.\n\nLike all \"tidyverse\" packages, to access the functions from the \"dplyr\" package, you just need to load the tidyverse library using `library(tidyverse)`.\n\nThe main dplyr functions you need to master are:\n\n- `select()`: extract columns from your data frame\n\n- `filter()`: filter to rows of your data frame based on a condition\n\n- `mutate()`: add columns or modify columns in your data frame\n\n- `summarize()`: aggregate information in your columns\n\n- `group_by()`: perform an operation separately for each entry in a categorical column\n\nOnce you feel comfortable with these five functions, you're officially a competent tidyverse R user. We're going to introduce all of them in this chapter, one by one. Then we're going to do fancy things like *combining* them together with something called the \"*pipe*\" (which looks like this: `|>` or like this `%>%` if you've been around the R scene for a while) \n\nReady? Let's go!\n\n\n\n\n## Select() for extacting columns\n\nWe can use the `select()` function to extract specific named columns from our data frame. \n\nThe *first argument* of `select()` is always the data frame on which you are operating, and all of the *remaining arguments* are the names of the columns that you want to keep. Note that the column names do *not* have quotes around them. This is something that makes dplyr (and tidyverse) functions special (and involves something called \"tidy evaluation\" that we won't talk about any time soon).\n\nSo if we want to extract just the country, year, and life expectancy columns from our gapminder data frame, we can write:\n\n```{r}\nselect(gapminder, country, year, lifeExp)\n```\n\n\nWe can also remove columns by using a minus sign in front of the column name. For example, the following code will return the gapminder data frame *without* the continent, year, and pop columns:\n\n```{r}\nselect(gapminder, -continent, -year, -pop)\n```\n\n\nSelect can also help you rename columns. If you just provide the column name as an argument, the column name will remain unchanged. However, if you provide the column name as `new_name = old_name`, the column will be renamed to whatever you provide as `new_name`. For example, the following code will return the gapminder data frame with the country, year, lifeExp, and gdpPercap columns, except the lifeExp column will be renamed to life_exp and the gdpPercap column renamed to gdp_per_cap:\n\n```{r}\nselect(gapminder, country, year, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\nHowever, since select will only return the columns that are included in its arguments, if you want to rename a column without removing any columns, you might want to use the `rename()` function instead. \n\nFor example, the following code will return *all columns* in the gapminder data frame, with the lifeExp column renamed to life_exp and the gdpPercap column renamed to gdp_per_cap:\n\n\n```{r}\nrename(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\n:::: {.panel-tabset}\n\n## Question\n\nWhat would happen if I replaced `rename()` in the code above with `select()`? \n\n## Answer \n\n```{r}\nselect(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap)\n```\n\n\n::::\n\n\n\n\n\n\n\n## The pipe `|>` (formerly `%>%`)\n\nRemember how I was being all gushy about the tidyverse? Honestly, the main reason for that is the **pipe**. The pipe makes is so we can read our code as if it is a sentence. For example, if I wanted to turn the following sentence \"*I take my backpack and then I put books in it and then put it on my back*\" using the pipe, I would write `backpack |> put_books_in() |> put_on_back()`. I always think of the pipe operator `|>` as the word \"and then\" in a sentence. \n\nSo for the following code, I can read it as \"*take the gapminder data frame and then select the country, year, and lifeExp columns*\":\n\n```{r}\ngapminder |> select(country, year, lifeExp)\n```\n\n\nThe pipe syntax is: `object |> function()`. The way it works is that the object to the left of the pipe (`|>`) is placed into the *first argument* of the function to the right of the pipe (`|>`).\n\nThis means that the following two pieces of code are equivalent:\n\n```{r}\n# apply head() to gapminder directly\nhead(gapminder)\n# apply head() to gapminder using the pipe\ngapminder |> head()\n```\n\nThe second version with the pipe takes the `gapminder` data frame (which is to the left of the pipe) and places it into the (first) argument of the `head()` function on the right of the pipe. The pipe always has an object (like a data frame) on its left and a function on its right.\n\nHere is another example of two pieces of equivalent code, first one with the pipe:\n\n```{r}\n# apply select to gapminder, year, and pop without the pipe\nselect(gapminder, year, pop)\n```\n\nAnd the version with the pipe:\n\n```{r}\n# apply select to gapminder, year, and pop with the pipe\ngapminder |> select(year, pop)\n```\n\nRemember that the pipe places the object on the left of the pipe into the first argument of the function on the right of the pipe. So if the function takes more than one argument (as `select()` does), then you place the remaining arguments inside the parentheses of the function on the right of the pipe.\n\n\n:::{.callout-tip}\n## The \"new\" pipe `|>` versus the \"old\" pipe `%>%`\n\nThe pipe `|>` is now a part of the R programming language. Previously, you needed to load the magrittr, dplyr, or tidyverse libraries to access the pipe and it had a different symbol: `%>%` (there are very minor differences in functionality). This still works, but it is now recommended that you use the newer \"native\" pipe syntax: `|>`. \n:::\n\n\n\n\n## Filtering rows using filter()\n\n\nThe filter function lets you filter to specific rows based on a condition.\n\nImagine that we just want to look at the rows in the data corresponding to Australia. Recall that you can apply *logical operations* to a vector (in this case the \"country\" column of `gapminder`) as follows:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder$country == \"Australia\"\n```\n\nIf we just take the part of this statement that follows the `$` (i.e., `country == \"Australia\"`) and place it in the second argument of the `filter()` function, we can filter to just the rows in the data frame where the country is Australia (Note: no `$` extraction required!):\n\n```{r}\nfilter(gapminder, country == \"Australia\")\n```\n\nJust like `select()`, the first argument of `filter()` is always the data frame on which you are operating. The second argument of `filter()` is the condition that you want to use filter. Only the rows for which the condition is `TRUE` will be returned. However, you can refer to the column names without quotes inside dplyr functions, even though there is no `country` variable in our environment. \n\n### Multiple filtering conditions\n\nYou can provide multiple conditions using a comma, i.e., by providing multiple conditions as arguments to `filter()`. For example, the following code will filter the `gapminder` data frame to just the rows where both `country == \"Australia\"` AND `year > 1990` are `TRUE`. \n\n```{r}\nfilter(gapminder, country == \"Australia\", year > 1990)\n```\n\nAnd now that we have met our trusty pipe, we can rewrite this code as:\n\n```{r}\ngapminder |> filter(country == \"Australia\", year > 1990)\n```\n\nRemember that you can read this as \"take the gapminder data frame *and then* filter to the rows where the country is Australia and the year is greater than 1970\".\n\nWhile the pipe might not seem to be bringing much to the party just yet, rest assured the pipe is a game changer. To start to get a sense of why, let's use it to combine some sequential `filter()` and `select()` operations. \n\nFirst: filter to the continent of Africa, where the year is equal to 1992\n\nThen: return just the country and lifeExp columns (rename lifeExp to be life_exp)\n\n```{r}\ngapminder |> \n  filter(continent == \"Africa\", year == 1992) |> \n  select(country, life_exp = lifeExp)\n```\n\nNote that I like to start a new line *after* each pipe `|>` to make the code more readable. \n\nHow would you read this code as a sentence? I would read it as \"take the gapminder dataset *and then* filter to just the rows where the continent column is equal to \"Africa\" and the year is equal to 1992 *and then* select just the country and life expectancy columns, renaming life expectancy to be life_exp\".\n\nIf I wanted to try to write this code without the pipe, I would have to do it in a few steps like this:\n\n```{r}\ngapminder_africa_1992 <- filter(gapminder, continent == \"Africa\", year == 1992)\nselect(gapminder_africa_1992, country, life_exp = lifeExp)\n```\n\nWithout the pipe, I am forced to define an intermediate object, `gapminder_africa_1992` (or do some kind of disgusting nested function stuff), which feels inefficient now that we have the pipe. The pipe allows me to do everything in a single more readable and efficient operation.\n\n### The order of operations\n\nIt turns out that the order of operations can be fairly important.\n\nFor example, if I swap the order of the `select()` operation and the `filter()` operation in the code above, I will get an error:\n\n```{r}\n#| error: true\n\n# swap the filter and select steps above\ngapminder |> \n  select(country, life_exp = lifeExp) |>\n  filter(continent == \"Africa\", year == 1992) \n```\n\nWhy do you think this happens? Take a look at the error message for a hint. The issue is not that the `gapminder` object itself doesn't contain a \"continent\" column... what data frame is being piped into the `filter()` function? You can run just the first two lines of code to see:\n\n\n```{r}\ngapminder |> \n  select(country, life_exp = lifeExp) \n```\n\nThis is the data frame that is being piped into `filter()`. Does it contain a \"continent\" column? No it does not! So the `filter()` function is trying to filter to rows for which the \"continent\" column is equal to \"Africa\" in a data frame that doesn't contain a \"continent\" column. The following two pieces of code are therefore *not* equivalent:\n\n```{r}\n#| eval: false\ngapminder |> \n  filter(continent == \"Africa\", year == 1992) |>\n  select(country, life_exp = lifeExp) \n  \n```\n\n\n```{r}\n#| eval: false\ngapminder |> \n  select(country, life_exp = lifeExp) |>\n  filter(continent == \"Africa\", year == 1992) \n```\n\n\n### Filtering using \"OR\" conditions\n\nHow would you go about filtering to the rows where country corresponds to Australia and Italy. You might imagine that you can just provide these two conditions separated by a comma, as in:\n\n```{r}\ngapminder |> filter(country == \"Australia\", country == \"Italy\")\n```\n\nHowever, this has returned an *empty* data frame with 0 rows. Why has this happened?\n\nRemember that whenever you provide two conditions to `filter()` with a comma, R filters to the rows where *both* conditions are true. That is, a comma corresponds to an \"AND\" condition: `filter(country == \"Australia\", country == \"Italy\")` means \"filter to the rows where `country == \"Australia\"` AND `country == \"Italy\"` are both true. However, there are no rows where `country` is simultaneously equal to \"Australia\" and \"Italy\". It is only ever equal to one or the other. \n\nAlthough I phrased my desire as \"filter to the rows where country country corresponds to Australia **and** Italy\", I really meant, \"filter to the rows country corresponds to Australia **or** Italy\".\n\nCan you remember how to ask an \"OR\" question? You use the vertical bar `|`. So to ask this question, I could provide two conditions separated by a vertical bar `(condition 1) | (condition 2)`, which will return all rows where *either* condition 1 *or* condition 2 are satisfied.\n\n\n```{r}\ngapminder |> filter((country == \"Australia\") | (country == \"Italy\"))\n```\n\n\nOr if both conditions involve the same variable (in this case, `country`), you can use the `%in%` operator! Remember that you can ask which values in a vector are also in some other vector, such as asking which values in the vector `c(1, 5, 2, 2, 1, 6)` are equal to `1` or `2` (i.e., are in the vector `c(1, 2)`) by writing:\n\n```{r}\nc(1, 5, 2, 2, 1, 6) %in% c(1, 2)\n```\n\n\nWe can use this same `%in% `operator to ask which entries of `country` column are equal to `\"Australia\"` or `\"Italy\"`:\n\n```{r}\ngapminder |> filter(country %in% c(\"Australia\", \"Italy\"))\n```\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nFilter gapminder to all countries on the Oceania continent for just the years 1987 and 1992 and select just the country, year, and gdpPercap columns (where you have renamed `gdpPercap` to be `gdp_per_cap`). \n\nSave the output in an object called gapminder_oceania, and print `gapminder_oceania` to the console.\n\n## Solution\n\n```{r}\ngapminder_oceania <- gapminder |> \n  filter(continent == \"Oceania\", year %in% c(1987, 1992)) |>\n  select(country, year, gdp_per_cap = gdpPercap)\ngapminder_oceania\n```\n\n\n::::\n\n\n\n\n\n\n\n\n\n\n\n## Adding and modifying columns using mutate()\n\nLet's move from filtering our rows using `filter()` onto adding and modifying our columns using `mutate()`!\n\nIf I wanted to add a new column to my data, called `gdp`, which is the product of the `pop` and `gdpPercap` columns, I can do that using `mutate()`. \n\n```{r}\ngapminder |> mutate(gdp = pop * gdpPercap) \n```\n\nRemember that the code above hasn't actually modified gapminder. To modify gapminder I would need to *reassign* gapminder to the mutated dataframe: `gaminder <- gapminder |> mutate(gdp = pop * gdpPercap)`.\n\nWhat this code has done is it has created a brand new column, `gdp`, and plopped it at the end of my data frame (and it's printed out the resulting data frame without saving it as a new variable). In this case, each value in the `gdp` column contains product of the corresponding values in the `pop` and `gdpPercap` columns.\n\nThe general syntax for mutate is `df |> mutate(new column name = some operation involving existing columns)`, and because `mutate()` is a tidyverse function, we can refer to the columns of our data frame without needing quotes. \n\n\nAs another example, if we wanted to create a new column that contained the population in millions, i.e., divided by 1 million, we could do that using\n\n```{r}\ngapminder |> mutate(pop_mil = pop / 1e6)\n```\n\n\nNote that `1e6` is scientific notation for `1000000` (i.e., `1` followed by 6 `0`s).\n\nWhile `mutate()` is often used to create *new* columns, it can also be used to *modify existing* columns. For example, the code below will modify the existing `lifeExp` column by rounding it to the nearest integer. \n\n```{r}\ngapminder |> mutate(lifeExp = round(lifeExp)) \n```\n\nNote that no new columns have been added to the end of our `gapminder` output. The data frame contains the exact same columns as the original `gapminder` object, except the `lifeExp` column is now an integer!\n\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nModify `gapminder_tmp` using mutate() so that it contains a log(pop) column (in addition to the original `pop` column), and round the gdpPercap column to the nearest integer. The first 6 rows of your output should look like this:\n\n```{r}\n#| echo: false\n\ngapminder |> mutate(log_pop = log(pop), gdpPercap = round(gdpPercap)) |> head()\n```\n\n\n\n## Solution\n\n```{r}\ngapminder |> \n  mutate(log_pop = log(pop), gdpPercap = round(gdpPercap)) |> \n  head()\n```\n\n::::\n\n\n\n\n\n\n\n\n\n## Summarizing data frames using summarize()\n\nThe functions that we have discussed do far in this chapter (`select()`, `filter()` and `mutate()`) are all functions that can be used to create a *modified* version of your data frame.\n\nIn this section, we will introduce `summarize()`, which can be used to--you guessed it--*summarize* your data frame.\n\nAs an example, let's use summarize to compute the average `lifeExp` value across all rows in the dataset. If `lifeExp` was a vector object in our space, we would compute the average value by writing `mean(lifeExp)`. But since `lifeExp` is not a variable in our space, it is a column in our data, we can compute the average `lifeExp` value by providing this `mean(lifeExp)` operation inside the `summarize()` function as follows:\n\n```{r}\ngapminder |> summarize(mean(lifeExp))\n```\n\n\nYou can read this as: \"take the gapminder dataset *and then* summarize it by computing `mean(lifeExp)`, i.e., the mean of the `lifeExp` column\".\n\n\nHowever, like all of the other functions we have used in this chapter, the output of `summarize()` function is itself a data frame (albeit with just a single row and column). But notice that the name of the column in our summary data frame is just the function that was computed, `mean(lifeExp)`. Wouldn't it be nice if we could give this column a nicer name? Yes it would. Fortunately, this is super easy to do, by just providing a name for our summary operation inside the summary() function:\n\n```{r}\ngapminder |> summarize(mean_life_exp = mean(lifeExp))\n```\n\nIn this version, our one-row-one-column data frame has the column name `mean_life_exp`, instead of `mean(lifeExp)`. In general, I don't like having characters like `()` in the column names of my data frames, but this only really matters if I plan to use my data frame for something where I need to reference the column names (it matters less if I just want to look at it)!\n\n\nIt's also super easy to compute multiple summaries at once using our trusty comma:\n\n```{r}\ngapminder |> \n  summarize(mean_life_exp = mean(lifeExp), \n            max_population = max(pop))\n```\n\n\nYou don't need to put each summary computation on a new line, but it makes it a bit easier to read (e.g., compared with ` summarize(mean_life_exp = mean(lifeExp), max_population = max(pop))`).\n\n## Grouped operations with group_by()\n\nComputing a `summary()` operation across all of the rows at once is nice and all, but I'll forgive you if you're sitting there thinking \"Ok Rebecca, I know you love the tidyverse, and you want to pipe everything into everything else, but honestly it's just easier to use base R notation to do this, like:\"\n\n```{r}\nmean(gapminder$lifeExp)\n```\n\nAnd my response to you would be: yeah. It is. But just wait. The next thing I'm going to show you will blow your mind and force you to eat your words. \n\nWhat if... I asked you to compute the average life expectancy again, but to do it separately *for each continent*. \n\nWhile you could preceed your `summarize()` operation with a `filter()` operation for each continent like this:\n\n```{r}\ngapminder |> filter(continent == \"Asia\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Americas\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Africa\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Europe\") |> summarize(mean(lifeExp))\ngapminder |> filter(continent == \"Oceania\") |> summarize(mean(lifeExp))\n```\n\n\nOr even use a for loop (if you so desired...), it turns out that there is a better way!\n\nThe true value of the `summarize()` function lies in its friendship with the `group_by()` function. The following code concisely computes the average `lifeExp` separately for each `continent` by \"grouping\" the gapminder data frame by continent (using `group_by()`) *before* summarizing.\n\n```{r}\ngapminder |> \n  group_by(continent) |> \n  summarize(mean_life_exp = mean(lifeExp))\n```\n\n\nYou can think about this as if `group_by()` is creating a separate data frame for each continent and then it is computing the `summarize()` operation *separately* for each continent data frame, and it is then combining the summary output into a two-column data frame, where the first column contains the respective `continent` value, and the second column contains the result of the `summary()` operation for that particular `continent`.\n\nNow that's rad as heck!\n\n\n:::: {.panel-tabset}\n## Exercise\n\nUse group_by() and summarize() to compute the standard deviation of the `gdpPercap` column separately for each country.\n\n## Solution\n\n```{r}\ngapminder |> \n  group_by(country) |> \n  summarize(max_pop = max(pop))\n```\n::::\n\n\n\n\n\n\n\n### Group_by multiple columns simultaneously\n\nJust in case you weren't already impressed enough by the group_by/summarize duo, you can also do more sophisticated grouping operations, such as computing the average `lifeExp` for each continent-year * combination* by gropuing by both `continent` and `year`:\n\n```{r}\n# compute the average life expectancy for each continent-year combination\ngapminder |> \n  group_by(continent, year) |> \n  summarize(mean_life_exp = mean(lifeExp))\n```\n\n\nWith `filter()`, `mutate()`, `group_by()`, and `summarize()` up your sleeve, there is almost no summarization of your data you can't do!\n\n\n:::: {.panel-tabset}\n## Exercise\n\nCompute the mean and standard deviation of the GDP (the product of `pop` and `gdpPercap`) separately for each year and continent after the year 2000. Your output should look like this:\n\n```{r}\n#| echo: false\ngapminder |>\n  filter(year > 2000) |>\n  mutate(gdp = pop * gdpPercap) |>\n  group_by(year, continent) |>\n  summarize(mean(gdp))\n```\n\n## Hint\n\nOne suggested order of operations is \n\n```{{r}}\ngapminder |>\n  filter() |>\n  mutate() |>\n  group_by() |>\n  summarize()\n```\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(year > 2000) |>\n  mutate(gdp = pop * gdpPercap) |>\n  group_by(year, continent) |>\n  summarize(mean(gdp))\n```\n::::\n\n\nWhile `group_by()` is most often used with `summarize()`, this doesn't mean that it can *only* be used with `summarize()`!\n\n#### Grouped mutates\n\nBelow, I group by `continent` and then I conduct a `mutate()` to add a new column `max_life_exp`, containing the maximum life expectancy for the corresponding country:\n\n```{r}\ngapminder_new <- gapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) \nprint(gapminder_new, n = 30)\n```\n\nTake a close look at the new `max_life_exp` column that I've tacked onto the end of my data frame. It contains the same value within each country! This time, I have created a new data frame object called `gapminder_new` because I want to continue working with this data frame object.\n\n\n### Don't forget to `ungroup()`\n\nSo we've got our `gapminder_new` object that contains our `max_life_exp` column which contains the maximum life expectancy value where the average is computed just using the corresponding country's rows.\n\nIf I then wanted to conduct a subsequent summarize operation on this `gapminder_new` object, such as computing the average `max_life_exp` value, with the goal of computing this average *over all rows in the data* (i.e., I should get a single value), I might write the following code:\n\n```{r}\ngapminder_new |> summarize(mean(max_life_exp))\n```\n\n\nIs there anything surprising about the output here? The `summary()` operation is still *grouped by country*, despite the fact that I didn't conduct another `group_by(country)` operation before my `summarize()` operation!\n\nThis is because `gapminder_new` is not technically a simple data frame... it is a *grouped* data frame. \n\n\n```{r}\ngapminder_new\n```\n\n\nIn defining `gapminder_new`, I used a `group_by()` operation, and you can see that when I print out `gapminder_new`, at the very top (well, technically, just under the very top) you will see some text that says: `# Groups:   country [142]`. This tells me that `gapminder_new` is *grouped* by the country column (and there are 142 groups). This means that any operations that I conduct on `gapminder_new` will also be grouped (by `country`). \n\n\nIf you are going to continue working with a data frame that was created using a `group_by()` operation, it is important to remember to `ungroup()`, unless you want your subsequent operations to also be grouped. This is what I really wanted to do: \n\n```{r}\ngapminder_new |> ungroup() |> summarize(mean(max_life_exp))\n```\n\nI could write all of this code without defining my intermediate `gapminder_new` object as follows:\n\n```{r}\ngapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) |>\n  ungroup() |>\n  summarize(mean(max_life_exp))\n```\n\nBut if I forgot the `ungroup()` operation (the second-last line above), I get:\n\n```{r}\ngapminder |> \n  group_by(country) |>\n  mutate(max_life_exp = max(lifeExp)) |>\n  summarize(mean(max_life_exp))\n```\n\n\n### Grouped filtering\n\nYou can also conduct grouped filtering, which will apply your filter condition separately for each group. The most common scenario in which I find myself doing this is when I want to do something like filter to the row in each group with the maximum value in one of the columns, such as filtering to the rows with the highest `lifeExp` separately *within each continent*:\n\n```{r}\ngapminder |>\n  group_by(continent) |>\n  filter(lifeExp == max(lifeExp))\n```\n\n\n## Count\n\nThe second-last function I want to show you in this chapter is the `count()` function. `count()` is just a really handy function for summarizing categorical (character/factor) variables. `count()` creates a two-column data frame, where the first column contains the unique values in the variable provided to `count()`, in this case `continent`, and the second column, `n`, contains the number of times that each `continent` value appears:\n\n```{r}\ngapminder |>\n  count(continent)\n```\n\n\n\n\n\n\n\n## Arrange\n\nThe final function I have for you is `arrange()`, which lets you arrange the rows of your data frame in ascending or descending order of the values in a specific column. By default, `arrange()` will arrange the rows in ascending order. The following will rearrange all of the rows so that the row with the smallest `lifeExp` value will be at the top and the row with the largest `lifeExp` value will be at the bottom:\n\n```{r}\ngapminder |>\n  arrange(lifeExp)\n```\n\n\nFor some reason, the way that you specify that the rows should be arranged in *descending* order instead is to wrap the variable name in the `desc()` function. Now the row with the largest `lifeExp` value will be at the top and the row with the smallest `lifeExp` value will be at the bottom:\n\n```{r}\ngapminder |>\n  arrange(desc(lifeExp))\n```\n\nTechnically, you could also just arrange by the negative of the column to arrange in descending order, but I usually use the `desc()` approach myself. \n\n```{r}\ngapminder |>\n  arrange(-lifeExp)\n```\n\n\n\n\n\n\n\n\n\nTo finish up and make sure you were paying attention, here are a bunch of fun exercises for you to complete:\n\n:::: {.panel-tabset}\n\n## Exercise\n\nCompute the *median* lifeExp and maximum `pop` value for each country, and then arrange the countries in descending order of their maximum `pop` value.\n\n## Solution\n\n```{r}\ngapminder |>\n  group_by(country) |>\n  summarize(median_life_exp = median(lifeExp),\n            max_pop = max(pop)) |>\n  arrange(desc(max_pop))\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\n\nIdentify the 5 countries with the highest *average* life expectancy.\n\n## Solution\n\n```{r}\ngapminder |>\n  group_by(country) |>\n  summarize(mean_life_exp = mean(lifeExp)) |>\n  ungroup() |>\n  arrange(desc(mean_life_exp)) |> \n  head(5)\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\nWhat are the three most populous countries on the \"Asia\" continent?\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(continent == \"Asia\") |>\n  group_by(country) |>\n  summarize(max_pop = max(pop)) |>\n  ungroup() |>\n  arrange(desc(max_pop)) |>\n  head(3)\n```\n::::\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nIdentify the country with the highest total GDP for each continent.\n\n## Hint\n\nApply a filter after a group_by -- this will apply the filtering separately for each group.\n\n## Solution\n\nThese are the countries with the highest total GDP for each continent:\n\n```{r}\ngapminder |>\n  mutate(gdp = gdpPercap * pop) |>\n  group_by(continent) |>\n  filter(gdp == max(gdp)) |>\n  select(country, continent, gdp)\n```\n\n::::\n\n:::: {.panel-tabset}\n\n## Exercise\n\nCompute the average GDP per capita for each continent based only on countries with `gdpPercap` greater than 20,000.\n\n## Solution\n\n```{r}\ngapminder |>\n  filter(gdpPercap > 20000) |>\n  group_by(continent) |>\n  summarize(mean(gdpPercap))\n```\n\n::::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","embed-resources":true,"output-file":"05_dplyr.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","bibliography":["references.bib"],"theme":"cosmo","title":"Data Frames in the Tidyverse","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","embed-resources":true,"output-file":"05_dplyr.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","title":"Data Frames in the Tidyverse","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}