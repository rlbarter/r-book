{"title":"Data Frames","markdown":{"yaml":{"title":"Data Frames","format":"html","embed-resources":true,"editor_options":{"chunk_output_type":"console"}},"headingText":"three vectors containing info on each person's name, age, and favorite color","containsRefs":false,"markdown":"\n\nLet's imagine that you have an actual dataset containing a collection of columns (\"variables\" in data terminology) and rows (\"observations\" in data terminology). For example, maybe your dataset is:\n\n\n|Name|Age|Favorite Color|\n|:----|:----|:----|\n|Dean | 12 | Blue |\n|Xiao | 18 | Green |\n|Sara | 22 | Red |\n|Ravi | 21 | Purple |\n|Maya | 17 | Blue |\n\nIn this case, your dataset has three *\"variables\"* (name, age, and favorite color), and five *\"observations\"* for each of these variables (corresponding the values for 5 unique people). You might even recognize this data from the previous chapter: the values in the \"Age\" column are the values from our `age` vector and the names correspond to the names that we gave our age vector, along with some extra \"Favorite Color\" information.\n\nWhile we could define a separate vector variable in R for each column in our data, such as\n\n```{r}\nname_vec <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\nage_vec <- c(12, 18, 22, 21, 17)\ncolor_vec <- c(\"blue\", 'green', 'red', 'purple', 'blue')\n```\n\nOnce we started analyzing this data, it would quickly become hard to keep track of which age corresponded to which name, and what their corresponding favorite color is since the variables are each stored in three separate objects. For example, if I look at the `color_vec` vector by typing its name:\n\n```{r}\ncolor_vec\n```\n\nIt isn't clear whose color preference is whose.\n\nIt would be much nicer if we could create a *single* object containing all three of these variables such that the corresponding values are \"aligned\" in such a way that it is very clear that \"Ravi\" has age 21 and favorite color \"purple\".\n\nFortunately, the creators of R share our desires, and so they let us store each of our vectors in an object called a \"**data frame**\". \n\nIf I already have the columns of my data stored as separate vectors, I can create a data frame using the `data.frame()` function as follows:\n\n```{r}\nmy_data <- data.frame(name = name_vec,\n                      age = age_vec, \n                      color = color_vec)\n```\n\nWhere the name to the left of the `=` symbol in my `data.frame()` arguments defines the corresponding \"column name\" in my data frame.\n\nSince `my_data` is an R object, I can view it by typing its name:\n\n```{r}\nmy_data\n```\n\nNow our three variables are neatly arranged in rows and columns, where there is one row for each person and one column for each variable *and* this is all stored in a single variable/object called `my_data`. \n\nThe integer numbers 1, 2, 3, 4, and 5 shown along the left-hand side of the rows are not actually a part of the data object itself (notice that there is no \"column name\" printed above these integers). These numbers are just visual aids provided by the R console when you print a data frame object to make it a little bit easier to count the rows in the data.\n\n\nIf I ask R what kind of object `my_data` is, it tells me it's a \"data.frame\". \n\n```{r}\nclass(my_data)\n```\n\nAnd I can get a quick summary of what my data frame contains using the `str` function:\n\n```{r}\nstr(my_data)\n```\n\nIn particular, the things that I find helpful in this summary are the number of \"obs.\" (5) and \"variables\" (3), and the type/class of each variable shown after its name, which tells me that the `name` and `color` columns have a \"chr\" (character) type, and the `age` variable has a \"num\" (numeric) type. \n\nEach column in a data frame can have a different type, but *each entry within a single column must be the same type* (because each column corresponds to a vector).\n\nThere are several techniques for extracting the vectors stored in a data frame. For instance, if I wanted to extract the `age` column, or specifically, the vector corresponding to the `age` column, I can write:\n\n\n```{r}\nmy_data$age\n```\n\nor \n\n```{r}\nmy_data['age']\n```\n\nThese two approaches both extracted the `age` column, but notice that the output of these two column extraction techniques look a little different. \n\nCan you guess out why? Hint: What type/class do you think each output object has? Look at its formatting. Learning to recognize what type each object has based on the way it looks is a really helpful skill. \n\nThe output of `my_data$age` *looks* is an ordinary vector. I can tell because the values are arranged horizontally, and there is a `[1]` at the beginning of the output. But this isn't the case for the output of `my_data['age']`. The output here looks more like our data frame output (but with only one column).\n\nIndeed, if I ask R to tell me the class of each of these two objects that I have extracted, I learn that the `my_data$age` object has a \"numeric\" type (remember that a vector containing numeric values will have a \"numeric\" type!)\n\n```{r}\nclass(my_data$age)\n```\n\nand I learn that the `my_data['age']` object has a \"data.frame\" type:\n\n```{r}\nclass(my_data['age'])\n```\n\nSince data frames and vectors have different behaviors, there will be some scenarios where you prefer your extracted column to be a vector, and others where you will prefer your extracted column to be a single-column data frame.\n\nWhile I will occasionally want to extract columns from my data as a vector using one of these techniques, I typically conduct my data analyses and modifications using the data frame object itself. You'll see a range of techniques for working with data frames themselves in the next chapter.\n\nBut first, I want to show you how to load a dataset that you have saved on your computer into a data frame in R.\n\n\n## Loading in data from external files\n\n\nTo create the `my_data` data frame object above, I first created the individual vectors, which I then used to define the individual columns of my data frame within the `data.frame()` function. Imagine if your data had hundreds of observations/values for each of hundreds of variables. No one wants to manually type their data into R. \n\nMore often than not, the data you want to analyze will already live in a file on your computer, such as a .csv file or an Excel spreadsheet. In this section, I will show you how to \"load\" data from such files into an R data frame.\n\n\n\n\n### Loading data from .csv data files\n\n.csv files are one of the *simplest* data formats. \"csv\" stands for \"comma separated value\". In a .csv file:\n\n- Columns are separated by commas\n\n- New rows are created by starting a new line\n\nThe .csv version of our data above looks like this:\n\n```{verbatim}\nname, age, color\nDean, 12, blue\nXiao, 18, green\nSara,  22, red\nRavi, 21, purple\nMaya, 17, blue\n```\n\n\nTo load in a dataset (as a data frame) from a .csv file, we can use the `read.csv()` function. However, in order for R to be able to find your file you need to provide a \"filepath\" argument (as a character/text value) to your csv file.\n\nThe file path corresponds to the location where your file lives on your computer relative to where the current R file you are working in is saved. Ideally, you are working in a quarto document. If so, identify where on your computer you have saved your quarto document. If your csv data file lives in the same folder as your quarto document, then you will write \n\n```{r}\n#| eval: false\ndata <- read.csv(\"filename.csv\")\n```\n\nwhere you replace `\"filename.csv\"` which the actual file name of your .csv file. \n\nIf your .csv data file lives in a `data/` subfolder, then you will write \n\n```{r}\n#| eval: false\ndata <- read.csv(\"data/filename.csv\")\n```\n\n\nHowever, if you are running your code in the console, so that R knows where to start looking for the file, your console's \"working directory\" needs to match the location of your quarto document. The **working directory** is the folder on your computer where R looks for files to read and saves files you create.\n\nAll file paths in code that you run in the console will be relative to your current **working directory**, regardless of where your current quarto document is saved. \n\nIf you opened RStudio or positron or whichever IDE you are working in by opening a quarto document or R script directly, your working directory will (probably) be automatically set to the folder containing your quarto file. However, if you opened your IDE without opening a file, your working directory will most likely be your computer's home folder.\n\nIf your console's working directory does not match the location in which you saved your quarto document or R script (wherever you are saving the code that you are running), R will not be able to find your data files.\n\n::: {.callout-tip}\n## Identifying the console's current working directory\n\nYou can see your console's current working directory by looking at the top of the console. In the image below, the working directory is the \"Documents\" folder. If you just see `~`, then your console's current working directory is your computer's home page.\n\n```{r}\n#| echo: false\nknitr::include_graphics(\"figures/working_directory.png\")\n```\n\n:::\n\n:::{.callout-warning}\n## Changing your console's working directory\n\nIt is recommended that your working directory matches the location of the quarto document that you are working in. \n\nYou can update your console's working directory to be the location of your current quarto document in RStudio by choosing \"Session > Set Working Directory > To Source File Location\". \n:::\n\n\nLet's load a csv file. If you are working in a quarto document or an R script on your computer, take note of where you saved it. Create a new folder called \"data\" in the same location as your current document. Then download the gapminder dataset and move it to your new \"data\" folder.\n\nThen, assuming that your console's working directory matches the location where your quarto document or R script has been saved, you should be able to run this code below to load in the gapminder csv data file and save it as an object called `gapminder` using the `read.csv()` function.\n\n```{r}\ngapminder <- read.csv(file = \"data/gapminder.csv\")\n```\n\nIf you get an error that says `\"Warning message: In file(file, \"rt\") : cannot open file 'data/gapminder.csv': No such file or directory\"`, this means that either you did not set up your file in the right place, or your console's working directory is incorrect!\n\nHopefully you figured out how to tell R to find and load your dataset! If your code above worked, you should then be able to take a look at the gapminder object by typing its name:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder\n```\n\nBut this clearly prints out A LOT of data! \n\nIn general, you will want to try to avoid printing your entire dataset in your R console or quarto output. Try printing just the first few (6, to be exact) rows using the `head()` function:\n\n```{r}\nhead(gapminder)\n```\n\nSo what is this \"gapminder\" data? The gapminder dataset contains information on life expectancy, population, and GDP per capita for 142 countries over the years 1952 to 2007. If you want to learn more about it for some reason, head on over to the [gapminder website](https://www.gapminder.org/).\n\n\n### Describing attributes of a data frame\n\nNow that we have a data frame containing our data, we can print out just the column names using the `colnames()` function:\n\n```{r}\ncolnames(gapminder)\n```\n\nThis is particularly useful for data frames with a lot of columns.\n\nWe can also ask things like how many rows and columns our data frame has:\n\n```{r}\n# compute the number of rows (nrow)\nnrow(gapminder)\n# compute the number of columns (ncol)\nncol(gapminder)\n# do both at the same time (dim)\ndim(gapminder)\n```\n\nWe can use our trusty `str()` function from earlier to take a sneak peak at the \"structure\" of our data:\n\n```{r}\nstr(gapminder)\n```\n\nAnd we can use the `summary()` function to get some statistical summaries (like the minimum, median, mean, maximum and the quartiles) of each of the numeric columns in our data frame (this summary is fairly useless for character columns though):\n\n```{r}\n# use summary() to look at a summary of gapminder\nsummary(gapminder)\n```\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nYour turn: load the world happiness dataset from the `whr_2023.csv` file. Save it as a variable called `world_happiness`. Then print out the first 10 rows, the column names, create a summary of the data, report its dimension.\n\n\n## Solution\n\n```{r}\nworld_happiness <- read.csv(\"data/whr_2023.csv\")\nhead(world_happiness, 10)\n```\n\n\n```{r}\nstr(world_happiness)\nsummary(world_happiness)\n```\n\n\n```{r}\ndim(world_happiness)\n```\n\n\n::::\n\n\n\n\n\n## Installing and loading R packages {#sec-readxl}\n\nIf you are unfortunate enough to receive your data in the format of an Excel file, you can still load it into R! However, to load excel files, you will need to **install the \"readxl\" R package**. \n\nR packages are collections of \"add-on\" R functions that you can \"load\" into your R session to provide you with additional functionality. For example, the \"readxl\" package provides functions that allow you to read in data from Excel files.\n\nTo use functions from a package, you need to do two things:\n\n1. Install the package onto your computer. You only need to do this once.\n\n2. Load your package into your current R session. You need to do this every time you start a new R session (i.e., every time you open up RStudio).\n\nTo install the \"readxl\" package, you can write the following code *directly into your console*. I *don't* recommend saving this code in a quarto document or R script, because you only need to install a package once. \n\n```{r}\n#| eval: false\n# run in the console: \ninstall.packages(\"readxl\")\n```\n\nBut every time you want to *use* an installed R package in a new R session, you need to *\"load\"* it using the library() function (we R folk use the words \"library\" and \"package\" interchangeably). \n\n```{r}\nlibrary(readxl)\n```\n\nSince you need to run this every time you open RStudio, you should include this code at the top of your quarto document or R script.\n\nYou will often see a lot of message \"output\" when you load libraries. This is *completely normal*. Don't freak out. Unless you see the word \"Error\" in the message. Then it's not a message at all, it's an error, and you should probably freak out. Or just check that you've installed the package. Either works, but I imagine that one is more productive than the other.\n\nIf you are loading a library in a quarto document and you want to hide the message output in the resulting rendered document, you can use the chunk option `#| message: false`, such as:\n\n```{{r}}\n#| message: false\nlibrary(readxl)\n```\n\n\n## Loading data from Excel files \n\nOk, so now that we've loaded our \"readxl\" library, we should be able to use the `read_excel()` function! As you may have surmised, the `read_excel()` function will load in a dataset from an Excel file.\n\nJust for fun, I have also created an excel version of the gapminder data, `gapminder.xls`. Let's load that in using the `read_excel()` function from the \"readxl\" library. This code will only work if you have first installed the \"readxl\" package at some time in the past, and in this session you have run the `library(\"readxl\")` code to \"load\" the library into your R session. \n\n```{r}\ngapminder_excel <- read_excel(\"data/gapminder.xls\")\n```\n\nIf you have an excel file with lots of sheets, be aware that this function will only load the *first* sheet. However, you can use the `sheet` argument to load other sheets.\n\nIn the `gapminder.xls` file, you will see that there is in fact a second sheet, containing the rows for Australia only. To load in this second sheet, we use our `read_excel()` function with the `sheet = 2` argument:\n\n```{r}\n# use the \"sheet\" argument to load in just the second sheet containing Australia's data\ngapminder_excel_australia <- read_excel(\"data/gapminder.xls\", sheet = 2)\n```\n\n\n## Loading data from SPSS, Stata and SAS files using the haven package\n\nI'm not going to go into details here, but if you happen to have data in SPSS, Stata, or SAS file formats, the \"haven\" package has functions that you can use to load in these files.\n\nOnce you've installed (`install.packages(\"haven\")`) and loaded (`library(haven)`) the \"haven\" package, you should have access to the following functions:\n\n- **SAS**: `read_sas()` reads .sas7bdat and .sas7bcat files and `read_xpt()` reads SAS transport files (versions 5 and 8). \n\n- **SPSS**: `read_sav()` reads .sav files and `read_por()` reads the older .por files. \n\n- **Stata**: `read_dta()` reads .dta files (up to version 15). \n\n## Data Frames\n\n\nLet me preface the rest of this chapter by saying that I don't actually want you to read it, because there is a better way to do literally everything that is shown from this point in this chapter. Like way better. And that'll be the topic of the next chapter.\n\nSo why did I even write the following content? I wrote it because I want to show you the misery of working with data frames without the tidyverse. Without this content, you won't be able to fully appreciate the beauty of the tidyverse that will be introduced in the next chapter. If your only exposure to working with data in R is through the tidyverse, you'll take it for granted. Don't take the tidyverse for granted. It's special, Ok? Besides, if you haven't already, at some point in your R journeys you're going to encounter code written by other people that uses a lot of the syntax from this chapter, and I want to make sure that you understand it.\n\n\n\nThe rest of this chapter is all about working with data using \"base R\". When I say \"base R\" here, I mean R functions and syntax that are available to you without requiring that you install and load any additional packages. That is, they are part of the \"base\" R language itself. Since this chapter corresponds to a new quarto document, I'm going to go ahead and load our trust gapminder data frame using the `read.csv()` function (which is itself a base R function!!).\n\n```{r}\ngapminder <- read.csv(\"data/gapminder.csv\")\n```\n\nAnd let's take a look at the first few rows:\n\n```{r}\nhead(gapminder)\n```\n\n\n\n## Extracting columns from a data frame using the `$` operator\n\nIf you only take away one thing from this chapter, let it be that you can extract a column from a data frame using a dollar sign: `$`. Despite the fact that this is technically a \"base R\" technique for working with data frames, I do actually use it all the time. \n\nFor example, if I want to extract the `country` column from `gapminder` as a *vector*, I can write:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder$country\n```\n\nWhat kind of object is this? It's a (very long) vector! You can use the `head()` function on vectors too to just look at the first 6 values:\n\n```{r}\nhead(gapminder$country)\n```\n\n:::: {.panel-tabset}\n\n## Exercise \n\nExtract the `lifeExp` column from gapminder (I recommend using the `head()` function to limit the size of your output)\n\n## Solution\n\n```{r}\nhead(gapminder$lifeExp)\n```\n\n\n::::\n\n\n\n## Extracting individual entries from a data frame\n\nFor the rest of this chapter, I'm going to show you several base R techniques of extracting subsets of rows and columns from your data frame. I give you permission to skim.\n\nTo extract individual entries from a data frame using base R, you can write the name of the data frame object (such as `gapminder`) immediately followed by some *square* parentheses with two values separated by a comma. The first value will correspond to the row-number of the value you want to extract, and the second value will correspond to the column position of the value, which can either be the numeric index position (e.g., `2` for the second column) or the name of the column as a character value, such as `\"country\"`. \n\nFor example, to extract the entry in the 3rd row and 4th column of `gapminder`, you can write:\n\n```{r}\ngapminder[3, 4]\n```\n\nOr you can use the column name in the second (column) position of the square parentheses:\n\n```{r}\ngapminder[3, \"lifeExp\"]\n```\n\n\nIf you want to extract multiple values, you can use the `c()` function to create a vector of row or column indices. For example, to extract the entries in the 3rd and 4th rows and 4th column, you can write:\n\n```{r}\ngapminder[c(3, 4), 4]\n```\n\nand if you want to extract the entries in the 3rd and 4th rows and the 4th and 5th columns, you can write:\n\n```{r}\ngapminder[c(3, 4), c(4, 5)]\n```\n\nOr you can use the column names:\n\n```{r}\ngapminder[c(3, 4), c(\"lifeExp\", \"pop\")]\n```\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nWhat type of object do each of these extraction techniques output? Before using the `class()` function to check, try and just look at the output and visually identify what type of object (vector, data frame, numeric value, etc) each output is.\n\n\n## Solution\n\nAny output object that contains an individual value is just a standalone value. Any output object that contains a single column is a vector. Any output object that contains multiple columns are a data frame. \n\n\n::::\n\n\n### Extracting entire columns from a data frame\n\n\n\nThere are many ways to extract a single *column* from a data frame using base R syntax. You've already seen one:\n\n```{r}\nhead(gapminder$lifeExp)\n```\n\nBut you can also use the square parenthesis syntax to extract an entire column by leaving the first row index position in the square parentheses blank. For example, the following code will extract the entire fourth column (and just print out the head):\n\n```{r}\nhead(gapminder[, 4])\n```\n\nAnd the following code will do the same thing using the name of the fourth column instead of its index position:\n\n```{r}\nhead(gapminder[, \"lifeExp\"])\n```\n\n\n\nHere's a fun question for you (and don't try to tell me I don't know what \"fun\" means!)... What do you think the output of the following code will be:\n\n```{r}\n#| eval: false\nhead(gapminder[3])\n```\n\nAnd what about:\n\n```{r}\n#| eval: false\nhead(gapminder[\"year\"])\n```\n\nHow is this code different from what we were just doing above? \n\nAbove whenever we were using the square parenthesis syntax, we provided two values: the row position and the column position. If we wanted all of the rows, we left the row position blank, but we still had the comma, for example `gapminder[,3]`. But in the code above, we only provided one value, and no commas inside the square parentheses! \n\nIf you tried it out yourself, you will have seen that the output of these two pieces of code above where we just provide a number of a column name inside the square parentheses without any commas is the relevant column, but what type of object is it? Is `gapminder[\"year\"]` different from `gapminder[, \"year\"]`? Take a look at the two outputs:\n\n```{r}\nhead(gapminder[, \"year\"])\n```\n\n```{r}\nhead(gapminder[\"year\"])\n```\n\nWhat type of objects are they? The first one is a vector, and the second one is a single-column data frame!\n\n\nAnd just to confuse you even further, there is yet another way to extract a column: you can use double square parentheses `[[]]`. \n\n```{r}\nhead(gapminder[[3]])\nhead(gapminder[[\"year\"]])\n```\n\nIf you want the technical explanation of why this works, a data frame can be thought of as a \"list\" of vectors, and the way that you extract entries from a list is using double square parentheses, so `df[[3]]` will extract the third vector of the list, which is the same as the third column of the data frame. If you've never seen a list before, don't worry for now. We will talk about lists later in this book, but I'll introduce them properly when that time comes. We don't really need to know about lists to work with data frames.\n\n\n:::: {.panel-tabset}\n## Exercise\n\n\n1. Extract the `gdpPercap` entry for the fourth and fifth rows\n\n\n2. Extract the entire `lifeExp` column in as many different ways as you can (you may want to just look at the head() of your outputs).\n\n\n## Solution\n\n1. \n\n```{r}\ngapminder[c(4, 5), \"gdpPercap\"]\ngapminder[c(4, 5), 6]\ngapminder[c(4, 5), ncol(gapminder)]\n```\n\n\n2. \n\n```{r}\n# 7 ways of extracting the lifeExp column\nhead(gapminder[, 4])\nhead(gapminder[, \"lifeExp\"])\n\nhead(gapminder$lifeExp)\n\nhead(gapminder[4])\nhead(gapminder[\"lifeExp\"])\n\nhead(gapminder[[4]])\nhead(gapminder[[\"lifeExp\"]])\n```\n\n::::\n\n\n\n## Using logical indexing to extract subsets of data frames\n\nWhile being able to extract subsets of your data frame using row and column position, you probably don't want to have to figure out the row and column positions of every value that you want to extract. Fortunately, you don't have to! You can use that logical subsetting stuff that I went on and on about way back in @sec-logical-subsetting.\n\nLet's use logical subsetting to create a logical vector, called `is_aus` that is `TRUE` when the corresponding row's country value is \"Australia\" and `FALSE` otherwise.\n\n\n```{r}\nis_aus <- gapminder$country == \"Australia\"\n```\n\nRemember that `vec == \"value\"` will ask whether every value in the vector `vec` (in our example, this is the country column of gapminder `gapminder$country`) is equal to `\"Australia\"`, and will return `TRUE` if it is and `FALSE` if it is not. So the `is_aus` variable will contain a vector of `TRUE` and `FALSE` values. Since this vector is going to be long (its length equals the number of rows in `gapminder`), let's just look at the first 100 entries using `head()` (we can specify how many rows we want to look at by providing a second argument to head, in this case, `100`):\n\n```{r}\nhead(is_aus, 100)\n```\n\nOne trick to ask how many `TRUE` values there are in a logical vector is to use the `sum()` function. This is because `TRUE` is treated as `1` and `FALSE` is treated as `0`, so the sum of a logical vector will be the number of `TRUE` values in the vector.\n\n```{r}\nsum(is_aus)\n```\n\nSo why do we want to create this logical vector? It turns out that we can use it to filter to just the rows for Australia by providing it in the row indexing position of our square parentheses like this:\n\n```{r}\ngapminder[is_aus, ]\n```\n\nSince I didn't provide anything in the second position `[is_aus, ]`, this returned all of the columns.\n\nThis is pretty helpful, but it can get kind of messy, especially if we want to avoid defining intermediate objects (which I generally do). The way I wrote the code above involved defining an \"intermediate object\" corresponding to the `is_aus` logical vector:\n\n```{r}\nis_aus <- gapminder$country == \"Australia\"\ngapminder[is_aus, ]\n```\n\nBut I could have done this all in one row by writing:\n\n```{r}\ngapminder[gapminder$country == \"Australia\", ]\n```\n\nYou will often see this kind of code. For now, it's still fairly readable, but if I want to proide multiple conditions for my filtering, for example I just want to subset to the rows corresponding to `country == \"Australia\"` and `year > 1990`, I can do this by using the `&` operator to combine the two logical vectors:\n\n```{r}\ngapminder[(gapminder$country == \"Australia\") & (gapminder$year > 1990), ]\n```\n\nWhere our row condition `(gapminder$country == \"Australia\") & (gapminder$year > 1990)` will return a logical vector that is `TRUE` when both conditions are met and `FALSE` otherwise:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\n(gapminder$country == \"Australia\") & (gapminder$year > 1990)\n```\n\nThis gets messy fairly quickly, and I personally find it kind of hard to read. But don't worry, in the next chapter, I will show you a much nicer way to do this!\n\n\n\n\n\n## Removing columns using negative indexing\n\nRemember how you could remove a value from a vector by providing a negative value inside the indexing parentheses, such as `vec[-2]` for removing the second entry of the vector. \n\nYou can use negative indexing to remove columns of a data frame too! The following code will remove the third column (`year`) from gapminder, and show just the first 6 rows:\n\n```{r}\nhead(gapminder[-3])\n```\n\nNote that this doesn't modify the original `gapminder` object, because I have not reassigned `gapminder` (which would involve writing `gapminder <- gapminder[-3]`). This code above just shows you what `gapminder` would look like if you removed the third column (And then looked at its head).\n\n\n\n\n\n\n## Adding columns\n\n\nJust as you can remove columns from a data frame using the square parenthesis index syntax, you can also *add* new columns to a data frame. However, since adding a column involve *assigning* the new column to somthing, this *will* modify the gapminder object. To avoid modifying our original `gapminder` object, let's create a new version of it called `gapminder_tmp` (for \"gapminder temporary\"). I can do that by assigning `gapminder_tmp` to `gapminder`:\n\n```{r}\ngapminder_tmp <- gapminder\n```\n\nIf I wanted to add a new column to `gapminder_tmp`, I can use the `$` syntax to define `gapminder_tmp$gdp` (the column I want to create that does not yet exist) by assigning it to the vector of values that I want it to contain.\n\nThe `gdp` column that I want to create will correspond to the product of the `gdpPercap` column and the `pop` column (note that `gapminder_tmp$gdpPercap` and `gapminder_tmp$pop` are both vectors and their product is also a vector):\n\n```{r}\ngapminder_tmp$gdp <- gapminder_tmp$gdpPercap * gapminder_tmp$pop\n```\n\nLet's take a look at our modified `gapminder_tmp` data frame:\n\n```{r}\nhead(gapminder_tmp)\n```\n\nNotice that there is a new `gdp` column at the end!\n\nNote that we could alternatively do this using the square parenthesis syntax:\n\n```{r}\ngapminder_tmp[, \"gdp\"] <- gapminder_tmp[, \"gdpPercap\"] * gapminder_tmp[, \"pop\"]\n```\n\nAs well as the using version of indexing that doesn't involve a row index position (i.e., `df[\"col\"]` instead of `df[, \"col\"]`:\n\n```{r}\ngapminder_tmp[\"gdp\"] <- gapminder_tmp[\"gdpPercap\"] * gapminder_tmp[\"pop\"]\n```\n\n\n\nThese all do the same thing!\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nModify the `lifeExp` column of `gapminder_tmp` so that it is rounded to the nearest integer (use `round()`). \n\n*Hint:* you can undo your changes to `gapminder_tmp` by reassigning it to the original `gapminder` object (`gapminder_tmp <- gapminder`)\n\n## Solution\n\n```{r}\n# for all rows:\ngapminder_tmp$lifeExp <- round(gapminder_tmp$lifeExp)\nhead(gapminder_tmp)\n```\n\n::::\n\nIn the next chapter I'm going to show you better ways of doing literally everything that I just showed you. So feel free to forget everything you just read. Get ready to enter into the tidyverse!\n","srcMarkdownNoYaml":"\n\nLet's imagine that you have an actual dataset containing a collection of columns (\"variables\" in data terminology) and rows (\"observations\" in data terminology). For example, maybe your dataset is:\n\n\n|Name|Age|Favorite Color|\n|:----|:----|:----|\n|Dean | 12 | Blue |\n|Xiao | 18 | Green |\n|Sara | 22 | Red |\n|Ravi | 21 | Purple |\n|Maya | 17 | Blue |\n\nIn this case, your dataset has three *\"variables\"* (name, age, and favorite color), and five *\"observations\"* for each of these variables (corresponding the values for 5 unique people). You might even recognize this data from the previous chapter: the values in the \"Age\" column are the values from our `age` vector and the names correspond to the names that we gave our age vector, along with some extra \"Favorite Color\" information.\n\nWhile we could define a separate vector variable in R for each column in our data, such as\n\n```{r}\n# three vectors containing info on each person's name, age, and favorite color\nname_vec <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\nage_vec <- c(12, 18, 22, 21, 17)\ncolor_vec <- c(\"blue\", 'green', 'red', 'purple', 'blue')\n```\n\nOnce we started analyzing this data, it would quickly become hard to keep track of which age corresponded to which name, and what their corresponding favorite color is since the variables are each stored in three separate objects. For example, if I look at the `color_vec` vector by typing its name:\n\n```{r}\ncolor_vec\n```\n\nIt isn't clear whose color preference is whose.\n\nIt would be much nicer if we could create a *single* object containing all three of these variables such that the corresponding values are \"aligned\" in such a way that it is very clear that \"Ravi\" has age 21 and favorite color \"purple\".\n\nFortunately, the creators of R share our desires, and so they let us store each of our vectors in an object called a \"**data frame**\". \n\nIf I already have the columns of my data stored as separate vectors, I can create a data frame using the `data.frame()` function as follows:\n\n```{r}\nmy_data <- data.frame(name = name_vec,\n                      age = age_vec, \n                      color = color_vec)\n```\n\nWhere the name to the left of the `=` symbol in my `data.frame()` arguments defines the corresponding \"column name\" in my data frame.\n\nSince `my_data` is an R object, I can view it by typing its name:\n\n```{r}\nmy_data\n```\n\nNow our three variables are neatly arranged in rows and columns, where there is one row for each person and one column for each variable *and* this is all stored in a single variable/object called `my_data`. \n\nThe integer numbers 1, 2, 3, 4, and 5 shown along the left-hand side of the rows are not actually a part of the data object itself (notice that there is no \"column name\" printed above these integers). These numbers are just visual aids provided by the R console when you print a data frame object to make it a little bit easier to count the rows in the data.\n\n\nIf I ask R what kind of object `my_data` is, it tells me it's a \"data.frame\". \n\n```{r}\nclass(my_data)\n```\n\nAnd I can get a quick summary of what my data frame contains using the `str` function:\n\n```{r}\nstr(my_data)\n```\n\nIn particular, the things that I find helpful in this summary are the number of \"obs.\" (5) and \"variables\" (3), and the type/class of each variable shown after its name, which tells me that the `name` and `color` columns have a \"chr\" (character) type, and the `age` variable has a \"num\" (numeric) type. \n\nEach column in a data frame can have a different type, but *each entry within a single column must be the same type* (because each column corresponds to a vector).\n\nThere are several techniques for extracting the vectors stored in a data frame. For instance, if I wanted to extract the `age` column, or specifically, the vector corresponding to the `age` column, I can write:\n\n\n```{r}\nmy_data$age\n```\n\nor \n\n```{r}\nmy_data['age']\n```\n\nThese two approaches both extracted the `age` column, but notice that the output of these two column extraction techniques look a little different. \n\nCan you guess out why? Hint: What type/class do you think each output object has? Look at its formatting. Learning to recognize what type each object has based on the way it looks is a really helpful skill. \n\nThe output of `my_data$age` *looks* is an ordinary vector. I can tell because the values are arranged horizontally, and there is a `[1]` at the beginning of the output. But this isn't the case for the output of `my_data['age']`. The output here looks more like our data frame output (but with only one column).\n\nIndeed, if I ask R to tell me the class of each of these two objects that I have extracted, I learn that the `my_data$age` object has a \"numeric\" type (remember that a vector containing numeric values will have a \"numeric\" type!)\n\n```{r}\nclass(my_data$age)\n```\n\nand I learn that the `my_data['age']` object has a \"data.frame\" type:\n\n```{r}\nclass(my_data['age'])\n```\n\nSince data frames and vectors have different behaviors, there will be some scenarios where you prefer your extracted column to be a vector, and others where you will prefer your extracted column to be a single-column data frame.\n\nWhile I will occasionally want to extract columns from my data as a vector using one of these techniques, I typically conduct my data analyses and modifications using the data frame object itself. You'll see a range of techniques for working with data frames themselves in the next chapter.\n\nBut first, I want to show you how to load a dataset that you have saved on your computer into a data frame in R.\n\n\n## Loading in data from external files\n\n\nTo create the `my_data` data frame object above, I first created the individual vectors, which I then used to define the individual columns of my data frame within the `data.frame()` function. Imagine if your data had hundreds of observations/values for each of hundreds of variables. No one wants to manually type their data into R. \n\nMore often than not, the data you want to analyze will already live in a file on your computer, such as a .csv file or an Excel spreadsheet. In this section, I will show you how to \"load\" data from such files into an R data frame.\n\n\n\n\n### Loading data from .csv data files\n\n.csv files are one of the *simplest* data formats. \"csv\" stands for \"comma separated value\". In a .csv file:\n\n- Columns are separated by commas\n\n- New rows are created by starting a new line\n\nThe .csv version of our data above looks like this:\n\n```{verbatim}\nname, age, color\nDean, 12, blue\nXiao, 18, green\nSara,  22, red\nRavi, 21, purple\nMaya, 17, blue\n```\n\n\nTo load in a dataset (as a data frame) from a .csv file, we can use the `read.csv()` function. However, in order for R to be able to find your file you need to provide a \"filepath\" argument (as a character/text value) to your csv file.\n\nThe file path corresponds to the location where your file lives on your computer relative to where the current R file you are working in is saved. Ideally, you are working in a quarto document. If so, identify where on your computer you have saved your quarto document. If your csv data file lives in the same folder as your quarto document, then you will write \n\n```{r}\n#| eval: false\ndata <- read.csv(\"filename.csv\")\n```\n\nwhere you replace `\"filename.csv\"` which the actual file name of your .csv file. \n\nIf your .csv data file lives in a `data/` subfolder, then you will write \n\n```{r}\n#| eval: false\ndata <- read.csv(\"data/filename.csv\")\n```\n\n\nHowever, if you are running your code in the console, so that R knows where to start looking for the file, your console's \"working directory\" needs to match the location of your quarto document. The **working directory** is the folder on your computer where R looks for files to read and saves files you create.\n\nAll file paths in code that you run in the console will be relative to your current **working directory**, regardless of where your current quarto document is saved. \n\nIf you opened RStudio or positron or whichever IDE you are working in by opening a quarto document or R script directly, your working directory will (probably) be automatically set to the folder containing your quarto file. However, if you opened your IDE without opening a file, your working directory will most likely be your computer's home folder.\n\nIf your console's working directory does not match the location in which you saved your quarto document or R script (wherever you are saving the code that you are running), R will not be able to find your data files.\n\n::: {.callout-tip}\n## Identifying the console's current working directory\n\nYou can see your console's current working directory by looking at the top of the console. In the image below, the working directory is the \"Documents\" folder. If you just see `~`, then your console's current working directory is your computer's home page.\n\n```{r}\n#| echo: false\nknitr::include_graphics(\"figures/working_directory.png\")\n```\n\n:::\n\n:::{.callout-warning}\n## Changing your console's working directory\n\nIt is recommended that your working directory matches the location of the quarto document that you are working in. \n\nYou can update your console's working directory to be the location of your current quarto document in RStudio by choosing \"Session > Set Working Directory > To Source File Location\". \n:::\n\n\nLet's load a csv file. If you are working in a quarto document or an R script on your computer, take note of where you saved it. Create a new folder called \"data\" in the same location as your current document. Then download the gapminder dataset and move it to your new \"data\" folder.\n\nThen, assuming that your console's working directory matches the location where your quarto document or R script has been saved, you should be able to run this code below to load in the gapminder csv data file and save it as an object called `gapminder` using the `read.csv()` function.\n\n```{r}\ngapminder <- read.csv(file = \"data/gapminder.csv\")\n```\n\nIf you get an error that says `\"Warning message: In file(file, \"rt\") : cannot open file 'data/gapminder.csv': No such file or directory\"`, this means that either you did not set up your file in the right place, or your console's working directory is incorrect!\n\nHopefully you figured out how to tell R to find and load your dataset! If your code above worked, you should then be able to take a look at the gapminder object by typing its name:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder\n```\n\nBut this clearly prints out A LOT of data! \n\nIn general, you will want to try to avoid printing your entire dataset in your R console or quarto output. Try printing just the first few (6, to be exact) rows using the `head()` function:\n\n```{r}\nhead(gapminder)\n```\n\nSo what is this \"gapminder\" data? The gapminder dataset contains information on life expectancy, population, and GDP per capita for 142 countries over the years 1952 to 2007. If you want to learn more about it for some reason, head on over to the [gapminder website](https://www.gapminder.org/).\n\n\n### Describing attributes of a data frame\n\nNow that we have a data frame containing our data, we can print out just the column names using the `colnames()` function:\n\n```{r}\ncolnames(gapminder)\n```\n\nThis is particularly useful for data frames with a lot of columns.\n\nWe can also ask things like how many rows and columns our data frame has:\n\n```{r}\n# compute the number of rows (nrow)\nnrow(gapminder)\n# compute the number of columns (ncol)\nncol(gapminder)\n# do both at the same time (dim)\ndim(gapminder)\n```\n\nWe can use our trusty `str()` function from earlier to take a sneak peak at the \"structure\" of our data:\n\n```{r}\nstr(gapminder)\n```\n\nAnd we can use the `summary()` function to get some statistical summaries (like the minimum, median, mean, maximum and the quartiles) of each of the numeric columns in our data frame (this summary is fairly useless for character columns though):\n\n```{r}\n# use summary() to look at a summary of gapminder\nsummary(gapminder)\n```\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nYour turn: load the world happiness dataset from the `whr_2023.csv` file. Save it as a variable called `world_happiness`. Then print out the first 10 rows, the column names, create a summary of the data, report its dimension.\n\n\n## Solution\n\n```{r}\nworld_happiness <- read.csv(\"data/whr_2023.csv\")\nhead(world_happiness, 10)\n```\n\n\n```{r}\nstr(world_happiness)\nsummary(world_happiness)\n```\n\n\n```{r}\ndim(world_happiness)\n```\n\n\n::::\n\n\n\n\n\n## Installing and loading R packages {#sec-readxl}\n\nIf you are unfortunate enough to receive your data in the format of an Excel file, you can still load it into R! However, to load excel files, you will need to **install the \"readxl\" R package**. \n\nR packages are collections of \"add-on\" R functions that you can \"load\" into your R session to provide you with additional functionality. For example, the \"readxl\" package provides functions that allow you to read in data from Excel files.\n\nTo use functions from a package, you need to do two things:\n\n1. Install the package onto your computer. You only need to do this once.\n\n2. Load your package into your current R session. You need to do this every time you start a new R session (i.e., every time you open up RStudio).\n\nTo install the \"readxl\" package, you can write the following code *directly into your console*. I *don't* recommend saving this code in a quarto document or R script, because you only need to install a package once. \n\n```{r}\n#| eval: false\n# run in the console: \ninstall.packages(\"readxl\")\n```\n\nBut every time you want to *use* an installed R package in a new R session, you need to *\"load\"* it using the library() function (we R folk use the words \"library\" and \"package\" interchangeably). \n\n```{r}\nlibrary(readxl)\n```\n\nSince you need to run this every time you open RStudio, you should include this code at the top of your quarto document or R script.\n\nYou will often see a lot of message \"output\" when you load libraries. This is *completely normal*. Don't freak out. Unless you see the word \"Error\" in the message. Then it's not a message at all, it's an error, and you should probably freak out. Or just check that you've installed the package. Either works, but I imagine that one is more productive than the other.\n\nIf you are loading a library in a quarto document and you want to hide the message output in the resulting rendered document, you can use the chunk option `#| message: false`, such as:\n\n```{{r}}\n#| message: false\nlibrary(readxl)\n```\n\n\n## Loading data from Excel files \n\nOk, so now that we've loaded our \"readxl\" library, we should be able to use the `read_excel()` function! As you may have surmised, the `read_excel()` function will load in a dataset from an Excel file.\n\nJust for fun, I have also created an excel version of the gapminder data, `gapminder.xls`. Let's load that in using the `read_excel()` function from the \"readxl\" library. This code will only work if you have first installed the \"readxl\" package at some time in the past, and in this session you have run the `library(\"readxl\")` code to \"load\" the library into your R session. \n\n```{r}\ngapminder_excel <- read_excel(\"data/gapminder.xls\")\n```\n\nIf you have an excel file with lots of sheets, be aware that this function will only load the *first* sheet. However, you can use the `sheet` argument to load other sheets.\n\nIn the `gapminder.xls` file, you will see that there is in fact a second sheet, containing the rows for Australia only. To load in this second sheet, we use our `read_excel()` function with the `sheet = 2` argument:\n\n```{r}\n# use the \"sheet\" argument to load in just the second sheet containing Australia's data\ngapminder_excel_australia <- read_excel(\"data/gapminder.xls\", sheet = 2)\n```\n\n\n## Loading data from SPSS, Stata and SAS files using the haven package\n\nI'm not going to go into details here, but if you happen to have data in SPSS, Stata, or SAS file formats, the \"haven\" package has functions that you can use to load in these files.\n\nOnce you've installed (`install.packages(\"haven\")`) and loaded (`library(haven)`) the \"haven\" package, you should have access to the following functions:\n\n- **SAS**: `read_sas()` reads .sas7bdat and .sas7bcat files and `read_xpt()` reads SAS transport files (versions 5 and 8). \n\n- **SPSS**: `read_sav()` reads .sav files and `read_por()` reads the older .por files. \n\n- **Stata**: `read_dta()` reads .dta files (up to version 15). \n\n## Data Frames\n\n\nLet me preface the rest of this chapter by saying that I don't actually want you to read it, because there is a better way to do literally everything that is shown from this point in this chapter. Like way better. And that'll be the topic of the next chapter.\n\nSo why did I even write the following content? I wrote it because I want to show you the misery of working with data frames without the tidyverse. Without this content, you won't be able to fully appreciate the beauty of the tidyverse that will be introduced in the next chapter. If your only exposure to working with data in R is through the tidyverse, you'll take it for granted. Don't take the tidyverse for granted. It's special, Ok? Besides, if you haven't already, at some point in your R journeys you're going to encounter code written by other people that uses a lot of the syntax from this chapter, and I want to make sure that you understand it.\n\n\n\nThe rest of this chapter is all about working with data using \"base R\". When I say \"base R\" here, I mean R functions and syntax that are available to you without requiring that you install and load any additional packages. That is, they are part of the \"base\" R language itself. Since this chapter corresponds to a new quarto document, I'm going to go ahead and load our trust gapminder data frame using the `read.csv()` function (which is itself a base R function!!).\n\n```{r}\ngapminder <- read.csv(\"data/gapminder.csv\")\n```\n\nAnd let's take a look at the first few rows:\n\n```{r}\nhead(gapminder)\n```\n\n\n\n## Extracting columns from a data frame using the `$` operator\n\nIf you only take away one thing from this chapter, let it be that you can extract a column from a data frame using a dollar sign: `$`. Despite the fact that this is technically a \"base R\" technique for working with data frames, I do actually use it all the time. \n\nFor example, if I want to extract the `country` column from `gapminder` as a *vector*, I can write:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\ngapminder$country\n```\n\nWhat kind of object is this? It's a (very long) vector! You can use the `head()` function on vectors too to just look at the first 6 values:\n\n```{r}\nhead(gapminder$country)\n```\n\n:::: {.panel-tabset}\n\n## Exercise \n\nExtract the `lifeExp` column from gapminder (I recommend using the `head()` function to limit the size of your output)\n\n## Solution\n\n```{r}\nhead(gapminder$lifeExp)\n```\n\n\n::::\n\n\n\n## Extracting individual entries from a data frame\n\nFor the rest of this chapter, I'm going to show you several base R techniques of extracting subsets of rows and columns from your data frame. I give you permission to skim.\n\nTo extract individual entries from a data frame using base R, you can write the name of the data frame object (such as `gapminder`) immediately followed by some *square* parentheses with two values separated by a comma. The first value will correspond to the row-number of the value you want to extract, and the second value will correspond to the column position of the value, which can either be the numeric index position (e.g., `2` for the second column) or the name of the column as a character value, such as `\"country\"`. \n\nFor example, to extract the entry in the 3rd row and 4th column of `gapminder`, you can write:\n\n```{r}\ngapminder[3, 4]\n```\n\nOr you can use the column name in the second (column) position of the square parentheses:\n\n```{r}\ngapminder[3, \"lifeExp\"]\n```\n\n\nIf you want to extract multiple values, you can use the `c()` function to create a vector of row or column indices. For example, to extract the entries in the 3rd and 4th rows and 4th column, you can write:\n\n```{r}\ngapminder[c(3, 4), 4]\n```\n\nand if you want to extract the entries in the 3rd and 4th rows and the 4th and 5th columns, you can write:\n\n```{r}\ngapminder[c(3, 4), c(4, 5)]\n```\n\nOr you can use the column names:\n\n```{r}\ngapminder[c(3, 4), c(\"lifeExp\", \"pop\")]\n```\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nWhat type of object do each of these extraction techniques output? Before using the `class()` function to check, try and just look at the output and visually identify what type of object (vector, data frame, numeric value, etc) each output is.\n\n\n## Solution\n\nAny output object that contains an individual value is just a standalone value. Any output object that contains a single column is a vector. Any output object that contains multiple columns are a data frame. \n\n\n::::\n\n\n### Extracting entire columns from a data frame\n\n\n\nThere are many ways to extract a single *column* from a data frame using base R syntax. You've already seen one:\n\n```{r}\nhead(gapminder$lifeExp)\n```\n\nBut you can also use the square parenthesis syntax to extract an entire column by leaving the first row index position in the square parentheses blank. For example, the following code will extract the entire fourth column (and just print out the head):\n\n```{r}\nhead(gapminder[, 4])\n```\n\nAnd the following code will do the same thing using the name of the fourth column instead of its index position:\n\n```{r}\nhead(gapminder[, \"lifeExp\"])\n```\n\n\n\nHere's a fun question for you (and don't try to tell me I don't know what \"fun\" means!)... What do you think the output of the following code will be:\n\n```{r}\n#| eval: false\nhead(gapminder[3])\n```\n\nAnd what about:\n\n```{r}\n#| eval: false\nhead(gapminder[\"year\"])\n```\n\nHow is this code different from what we were just doing above? \n\nAbove whenever we were using the square parenthesis syntax, we provided two values: the row position and the column position. If we wanted all of the rows, we left the row position blank, but we still had the comma, for example `gapminder[,3]`. But in the code above, we only provided one value, and no commas inside the square parentheses! \n\nIf you tried it out yourself, you will have seen that the output of these two pieces of code above where we just provide a number of a column name inside the square parentheses without any commas is the relevant column, but what type of object is it? Is `gapminder[\"year\"]` different from `gapminder[, \"year\"]`? Take a look at the two outputs:\n\n```{r}\nhead(gapminder[, \"year\"])\n```\n\n```{r}\nhead(gapminder[\"year\"])\n```\n\nWhat type of objects are they? The first one is a vector, and the second one is a single-column data frame!\n\n\nAnd just to confuse you even further, there is yet another way to extract a column: you can use double square parentheses `[[]]`. \n\n```{r}\nhead(gapminder[[3]])\nhead(gapminder[[\"year\"]])\n```\n\nIf you want the technical explanation of why this works, a data frame can be thought of as a \"list\" of vectors, and the way that you extract entries from a list is using double square parentheses, so `df[[3]]` will extract the third vector of the list, which is the same as the third column of the data frame. If you've never seen a list before, don't worry for now. We will talk about lists later in this book, but I'll introduce them properly when that time comes. We don't really need to know about lists to work with data frames.\n\n\n:::: {.panel-tabset}\n## Exercise\n\n\n1. Extract the `gdpPercap` entry for the fourth and fifth rows\n\n\n2. Extract the entire `lifeExp` column in as many different ways as you can (you may want to just look at the head() of your outputs).\n\n\n## Solution\n\n1. \n\n```{r}\ngapminder[c(4, 5), \"gdpPercap\"]\ngapminder[c(4, 5), 6]\ngapminder[c(4, 5), ncol(gapminder)]\n```\n\n\n2. \n\n```{r}\n# 7 ways of extracting the lifeExp column\nhead(gapminder[, 4])\nhead(gapminder[, \"lifeExp\"])\n\nhead(gapminder$lifeExp)\n\nhead(gapminder[4])\nhead(gapminder[\"lifeExp\"])\n\nhead(gapminder[[4]])\nhead(gapminder[[\"lifeExp\"]])\n```\n\n::::\n\n\n\n## Using logical indexing to extract subsets of data frames\n\nWhile being able to extract subsets of your data frame using row and column position, you probably don't want to have to figure out the row and column positions of every value that you want to extract. Fortunately, you don't have to! You can use that logical subsetting stuff that I went on and on about way back in @sec-logical-subsetting.\n\nLet's use logical subsetting to create a logical vector, called `is_aus` that is `TRUE` when the corresponding row's country value is \"Australia\" and `FALSE` otherwise.\n\n\n```{r}\nis_aus <- gapminder$country == \"Australia\"\n```\n\nRemember that `vec == \"value\"` will ask whether every value in the vector `vec` (in our example, this is the country column of gapminder `gapminder$country`) is equal to `\"Australia\"`, and will return `TRUE` if it is and `FALSE` if it is not. So the `is_aus` variable will contain a vector of `TRUE` and `FALSE` values. Since this vector is going to be long (its length equals the number of rows in `gapminder`), let's just look at the first 100 entries using `head()` (we can specify how many rows we want to look at by providing a second argument to head, in this case, `100`):\n\n```{r}\nhead(is_aus, 100)\n```\n\nOne trick to ask how many `TRUE` values there are in a logical vector is to use the `sum()` function. This is because `TRUE` is treated as `1` and `FALSE` is treated as `0`, so the sum of a logical vector will be the number of `TRUE` values in the vector.\n\n```{r}\nsum(is_aus)\n```\n\nSo why do we want to create this logical vector? It turns out that we can use it to filter to just the rows for Australia by providing it in the row indexing position of our square parentheses like this:\n\n```{r}\ngapminder[is_aus, ]\n```\n\nSince I didn't provide anything in the second position `[is_aus, ]`, this returned all of the columns.\n\nThis is pretty helpful, but it can get kind of messy, especially if we want to avoid defining intermediate objects (which I generally do). The way I wrote the code above involved defining an \"intermediate object\" corresponding to the `is_aus` logical vector:\n\n```{r}\nis_aus <- gapminder$country == \"Australia\"\ngapminder[is_aus, ]\n```\n\nBut I could have done this all in one row by writing:\n\n```{r}\ngapminder[gapminder$country == \"Australia\", ]\n```\n\nYou will often see this kind of code. For now, it's still fairly readable, but if I want to proide multiple conditions for my filtering, for example I just want to subset to the rows corresponding to `country == \"Australia\"` and `year > 1990`, I can do this by using the `&` operator to combine the two logical vectors:\n\n```{r}\ngapminder[(gapminder$country == \"Australia\") & (gapminder$year > 1990), ]\n```\n\nWhere our row condition `(gapminder$country == \"Australia\") & (gapminder$year > 1990)` will return a logical vector that is `TRUE` when both conditions are met and `FALSE` otherwise:\n\n```{r}\n#| attr-output: 'style=\"height: 400px\"'\n(gapminder$country == \"Australia\") & (gapminder$year > 1990)\n```\n\nThis gets messy fairly quickly, and I personally find it kind of hard to read. But don't worry, in the next chapter, I will show you a much nicer way to do this!\n\n\n\n\n\n## Removing columns using negative indexing\n\nRemember how you could remove a value from a vector by providing a negative value inside the indexing parentheses, such as `vec[-2]` for removing the second entry of the vector. \n\nYou can use negative indexing to remove columns of a data frame too! The following code will remove the third column (`year`) from gapminder, and show just the first 6 rows:\n\n```{r}\nhead(gapminder[-3])\n```\n\nNote that this doesn't modify the original `gapminder` object, because I have not reassigned `gapminder` (which would involve writing `gapminder <- gapminder[-3]`). This code above just shows you what `gapminder` would look like if you removed the third column (And then looked at its head).\n\n\n\n\n\n\n## Adding columns\n\n\nJust as you can remove columns from a data frame using the square parenthesis index syntax, you can also *add* new columns to a data frame. However, since adding a column involve *assigning* the new column to somthing, this *will* modify the gapminder object. To avoid modifying our original `gapminder` object, let's create a new version of it called `gapminder_tmp` (for \"gapminder temporary\"). I can do that by assigning `gapminder_tmp` to `gapminder`:\n\n```{r}\ngapminder_tmp <- gapminder\n```\n\nIf I wanted to add a new column to `gapminder_tmp`, I can use the `$` syntax to define `gapminder_tmp$gdp` (the column I want to create that does not yet exist) by assigning it to the vector of values that I want it to contain.\n\nThe `gdp` column that I want to create will correspond to the product of the `gdpPercap` column and the `pop` column (note that `gapminder_tmp$gdpPercap` and `gapminder_tmp$pop` are both vectors and their product is also a vector):\n\n```{r}\ngapminder_tmp$gdp <- gapminder_tmp$gdpPercap * gapminder_tmp$pop\n```\n\nLet's take a look at our modified `gapminder_tmp` data frame:\n\n```{r}\nhead(gapminder_tmp)\n```\n\nNotice that there is a new `gdp` column at the end!\n\nNote that we could alternatively do this using the square parenthesis syntax:\n\n```{r}\ngapminder_tmp[, \"gdp\"] <- gapminder_tmp[, \"gdpPercap\"] * gapminder_tmp[, \"pop\"]\n```\n\nAs well as the using version of indexing that doesn't involve a row index position (i.e., `df[\"col\"]` instead of `df[, \"col\"]`:\n\n```{r}\ngapminder_tmp[\"gdp\"] <- gapminder_tmp[\"gdpPercap\"] * gapminder_tmp[\"pop\"]\n```\n\n\n\nThese all do the same thing!\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nModify the `lifeExp` column of `gapminder_tmp` so that it is rounded to the nearest integer (use `round()`). \n\n*Hint:* you can undo your changes to `gapminder_tmp` by reassigning it to the original `gapminder` object (`gapminder_tmp <- gapminder`)\n\n## Solution\n\n```{r}\n# for all rows:\ngapminder_tmp$lifeExp <- round(gapminder_tmp$lifeExp)\nhead(gapminder_tmp)\n```\n\n::::\n\nIn the next chapter I'm going to show you better ways of doing literally everything that I just showed you. So feel free to forget everything you just read. Get ready to enter into the tidyverse!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","embed-resources":true,"output-file":"04_data_frames.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","bibliography":["references.bib"],"theme":"cosmo","title":"Data Frames","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","embed-resources":true,"output-file":"04_data_frames.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","title":"Data Frames","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}